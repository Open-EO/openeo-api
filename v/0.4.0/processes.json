[
  {
    "id": "absolute",
    "summary": "Absolute value",
    "description": "Computes the absolute value of a real number `x`, which is the \"unsigned\" portion of x and often denoted as *|x|*.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed absolute value.",
      "schema": {
        "type": [
          "number",
          "null"
        ],
        "minimum": 0
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 3.5
      },
      {
        "arguments": {
          "x": -0.4
        },
        "returns": 0.4
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": 3.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/AbsoluteValue.html",
        "title": "Absolute value explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "add_dimension",
    "summary": "Add a new dimension",
    "description": "Adds a new named dimension to the data cube.\n\nAfterwards, the dimension can be referenced with the specified `name`. If a dimension with the specified name already exists, a `DimensionExists` exception is thrown. The values of the dimension are set to the specified `value`.",
    "categories": [
      "cubes"
    ],
    "parameter_order": [
      "data",
      "name",
      "value"
    ],
    "parameters": {
      "data": {
        "description": "A data cube to add the dimension to.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "name": {
        "description": "Name for the dimension.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "value": {
        "description": "Value for the dimension.",
        "schema": {
          "description": "Any data type is allowed."
        },
        "required": true
      }
    },
    "returns": {
      "description": "The data cube with a newly added dimension.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "exceptions": {
      "DimensionExists": {
        "message": "A dimension with the specified name already exists."
      }
    }
  },
  {
    "id": "aggregate_temporal",
    "summary": "Temporal aggregations",
    "description": "Computes a temporal aggregation based on an array of date or date and time ranges. Will be projected to the labels. Length of labels and groups needs to be the same. All data along the dimensions will be passed through the reducer. Calendar hierarchies such as year, month, week etc. will be transformed from the clients into groups.",
    "categories": [
      "cubes",
      "aggregate"
    ],
    "parameter_order": [
      "data",
      "groups",
      "labels",
      "reducer",
      "dimension"
    ],
    "parameters": {
      "data": {
        "description": "",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "groups": {
        "description": "",
        "schema": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": true
      },
      "labels": {
        "description": "",
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "required": true
      },
      "reducer": {
        "description": "",
        "schema": {
          "type": "object",
          "format": "callback",
          "properties": {
            "data": {
              "description": "An array with elements of any type.",
              "type": "array",
              "items": {
                "description": "Any data type."
              }
            }
          }
        },
        "required": true
      },
      "dimension": {
        "description": "",
        "schema": {
          "type": "string"
        },
        "required": true
      }
    },
    "returns": {
      "description": "A data cube with potentially lower resolution and potentially lower cardinality, but the same number of dimensions as the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "aggregate_zonal",
    "summary": "Zonal statistics for polygons",
    "description": "Aggregates zonal data/statistics for one or multiple GeoJSON features. For focal aggregation see ``apply()``. Number of valid/invalid pixels get returned together with the calculated values.",
    "categories": [
      "cubes",
      "aggregate"
    ],
    "parameter_order": [
      "data",
      "polygons",
      "dimension"
    ],
    "parameters": {
      "data": {
        "description": "",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "polygons": {
        "description": "",
        "schema": {
          "anyOf": [
            {
              "type": "object",
              "format": "geojson"
            },
            {
              "type": "object",
              "format": "vector-cube"
            }
          ]
        },
        "required": true
      },
      "dimension": {
        "description": "",
        "schema": {
          "type": "string"
        },
        "required": true
      }
    },
    "returns": {
      "description": "A vector data cube or a GeoJSON object, depending on the input for `polygons` parameter.",
      "schema": {
        "anyOf": [
          {
            "type": "object",
            "format": "geojson"
          },
          {
            "type": "object",
            "format": "vector-cube"
          }
        ]
      }
    }
  },
  {
    "id": "and",
    "summary": "Are all of the values true?",
    "description": "Checks if **all** of the values are true. Evaluates each expression from the first to the last element and stops once the outcome is unambiguous.\n\nIf only one value is given the process evaluates to the given value. If no value is given (i.e. the array is empty) the process returns `null`.\n\nBy default all no-data values are ignored so that the process returns `true` if all other values are true and otherwise returns `false`.\nSetting the `ignore_nodata` flag to `false` considers no-data values so that `null` is a valid logical object. If a component is `null`, the result will be `null` if the outcome is ambiguous. See the following truth table:\n\n```\n      || null  | false | true\n----- || ----- | ----- | -----\nnull  || null  | false | null\nfalse || false | false | false\ntrue  || null  | false | true\n```",
    "categories": [
      "logic",
      "reducer"
    ],
    "parameter_order": [
      "expressions",
      "ignore_nodata"
    ],
    "parameters": {
      "expressions": {
        "description": "A set of boolean values.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "boolean",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not and ignores them by default.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "Boolean result of the logical expressions.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "expressions": [
            false,
            null
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true,
            null
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            false,
            null
          ],
          "ignore_nodata": false
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "expressions": [
            true,
            false,
            true,
            false
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true,
            false
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true,
            true
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            true
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": []
        },
        "returns": null
      }
    ]
  },
  {
    "id": "apply_dimension",
    "summary": "Applies an n-ary process to one or more dimensions",
    "description": "Applies an n-ary process (i.e. takes an array of values instead of a single value) to a raster data cube. The n-ary process must return as many elements in the returned array as there are in the input array.\n\nThe dimensions over which to iterate with the parameter `dimensions` can be specified. The specified callback is applied to each of them individually. If the `dimensions` parameter is not set or an empty array, the process applies the callback to all dimensions.",
    "categories": [
      "cubes"
    ],
    "parameter_order": [
      "data",
      "process",
      "dimensions"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "process": {
        "description": "A process (callback) to be applied on each dimension. The specified process needs to accept an array as parameter and must return as many elements in the returned array as there are in the input array.",
        "schema": {
          "type": "object",
          "format": "callback",
          "properties": {
            "data": {
              "description": "An array with elements of any type.",
              "type": "array",
              "items": {
                "description": "Any data type."
              }
            }
          }
        },
        "required": true
      },
      "dimensions": {
        "description": "The names of the dimensions to apply the process on. Defaults to an empty array so that all dimensions are used.",
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "default": []
        }
      }
    },
    "returns": {
      "description": "A data cube with the newly computed values for the specified dimensions. The resolution, cardinality and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "apply_kernel",
    "summary": "Applies a kernel to compute pixel-wise values",
    "description": "Applies a a focal operation based on a weighted kernel to each value of the specified dimensions in the data cube.",
    "categories": [
      "math > image filter"
    ],
    "parameter_order": [
      "data",
      "kernel"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "kernel": {
        "description": "The kernel to be applied on the data cube. The kernel has to be as many dimensions as the data cube has dimensions.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Usually a multi-dimensional array of numbers."
          }
        },
        "required": true
      },
      "factor": {
        "description": "A factor multiplied to the computed value.\n\nThis is a shortcut for explicitly multiplying each value by a factor afterwards, which is often required for some kernel-based algorithms such as the Gaussian blur.",
        "schema": {
          "type": "number",
          "default": 1
        }
      }
    },
    "returns": {
      "description": "A data cube with the newly computed values. The resolution, cardinality and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "apply",
    "summary": "Applies a process to each pixel",
    "description": "Applies a unary process (a local operation) to each value of the specified or all dimensions in the data cube.",
    "categories": [
      "cubes"
    ],
    "parameter_order": [
      "data",
      "process",
      "dimensions"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "process": {
        "description": "A process (callback) to be applied on each value. The specified process must be unary meaning that it must work on a single value.",
        "schema": {
          "type": "object",
          "format": "callback",
          "properties": {
            "x": {
              "description": "A value of any data type could be passed."
            }
          }
        },
        "required": true
      },
      "dimensions": {
        "description": "The names of the dimensions to apply the process on. Defaults to an empty array so that all dimensions are used.",
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "default": []
        }
      }
    },
    "returns": {
      "description": "A data cube with the newly computed values. The resolution, cardinality and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "arccos",
    "summary": "Inverse cosine",
    "description": "Computes the arc cosine of `x`. The arc cosine is the inverse function of the cosine so that *arccos(cos(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 1
      },
      {
        "process_graph": {
          "cos1": {
            "process_id": "cos",
            "arguments": {
              "x": 0.5
            }
          },
          "arccos1": {
            "process_id": "arccos",
            "arguments": {
              "x": {
                "from_node": "cos1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseCosine.html",
        "title": "Inverse cosine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "arcosh",
    "summary": "Inverse hyperbolic cosine",
    "description": "Computes the inverse hyperbolic cosine of `x`. It is the inverse function of the hyperbolic cosine so that *arcosh(cosh(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 1
      },
      {
        "process_graph": {
          "cosh1": {
            "process_id": "cosh",
            "arguments": {
              "x": 0.5
            }
          },
          "arccosh1": {
            "process_id": "arcosh",
            "arguments": {
              "x": {
                "from_node": "cosh1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseHyperbolicCosine.html",
        "title": "Inverse hyperbolic cosine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "arcsin",
    "summary": "Inverse sine",
    "description": "Computes the arc sine of `x`. The arc sine is the inverse function of the sine so that *arcsin(sin(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "process_graph": {
          "sin1": {
            "process_id": "sin",
            "arguments": {
              "x": 0.5
            }
          },
          "arcsin1": {
            "process_id": "arcsin",
            "arguments": {
              "x": {
                "from_node": "sin1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseSine.html",
        "title": "Inverse sine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "arctan",
    "summary": "Inverse tangent",
    "description": "Computes the arc tangent of `x`. The arc tangent is the inverse function of the tangent so that *arctan(tan(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "process_graph": {
          "tan1": {
            "process_id": "tan",
            "arguments": {
              "x": 0.5
            }
          },
          "arctan1": {
            "process_id": "arctan",
            "arguments": {
              "x": {
                "from_node": "tan1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseTangent.html",
        "title": "Inverse tangent explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "arctan2",
    "summary": "Inverse tangent of two numbers.",
    "description": "Computes the arc tangent of two numbers `x` and `y`. It is similar to calculating the arc tangent of *y / x*, except that the signs of both arguments are used to determine the quadrant of the result.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated if any of the arguments is `null`.",
    "categories": [
      "math > trigonometric"
    ],
    "parameter_order": [
      "y",
      "x"
    ],
    "parameters": {
      "y": {
        "description": "A number to be used as dividend.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      },
      "x": {
        "description": "A number to be used as divisor.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "y": 0,
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "y": null,
          "x": 1.5
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Atan2",
        "title": "Two-argument inverse tangent explained by Wikipedia"
      }
    ]
  },
  {
    "id": "array_contains",
    "summary": "List contains an element",
    "description": "Checks whether the list (also known as *array*) specified for `data` contains the value specified in `element`.\n\n**Remarks:**\n\n* Data types MUST be checked strictly, for example a string with the content *1* is not equal to the number *1*.\n* An integer *1* is equal to a floating point number *1.0* as `integer` is a sub-type of `number`. Still, this process may return unexpectedly `false` when comparing floating point numbers due to floating point inaccuracy in machine-based computation.\n* Temporal strings are treated as normal strings and MUST NOT be interpreted.",
    "categories": [
      "arrays",
      "comparison"
    ],
    "parameter_order": [
      "data",
      "element"
    ],
    "parameters": {
      "data": {
        "description": "List in which to find a value in.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        },
        "required": true
      },
      "element": {
        "description": "Value to find in `data`.",
        "schema": {
          "description": "Any data type is allowed."
        },
        "required": true
      }
    },
    "returns": {
      "description": "Returns `true` if the list contains the value, false` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            2,
            3
          ],
          "element": 2
        },
        "returns": true
      },
      {
        "arguments": {
          "data": [
            "A",
            "B",
            "C"
          ],
          "element": "b"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3
          ],
          "element": "2"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3
          ],
          "element": 2
        },
        "returns": true
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            null
          ],
          "element": null
        },
        "returns": true
      },
      {
        "arguments": {
          "data": [
            [
              1,
              2
            ],
            [
              3,
              4
            ]
          ],
          "element": [
            1,
            2
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "data": [
            [
              1,
              2
            ],
            [
              3,
              4
            ]
          ],
          "element": 2
        },
        "returns": false
      },
      {
        "arguments": {
          "data": [
            {
              "a": "b"
            },
            {
              "c": "d"
            }
          ],
          "element": {
            "a": "b"
          }
        },
        "returns": true
      }
    ]
  },
  {
    "id": "array_element",
    "summary": "Get an element from an array",
    "description": "Returns the element at the specified index from the array.",
    "categories": [
      "arrays"
    ],
    "parameter_order": [
      "data",
      "index",
      "return_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        },
        "required": true
      },
      "index": {
        "description": "The zero-based index of the element to retrieve.",
        "schema": {
          "type": "integer"
        },
        "required": true
      },
      "return_nodata": {
        "description": "By default this process throws an `IndexOutOfBounds` exception if the index is invalid. If you want to return `null` instead, set this flag to `true`.",
        "schema": {
          "type": "boolean",
          "default": false
        }
      }
    },
    "returns": {
      "description": "The value of the requested element.",
      "schema": {
        "description": "Any data type is allowed."
      }
    },
    "exceptions": {
      "IndexOutOfBounds": {
        "message": "The array has no element with the specified index."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            9,
            8,
            7,
            6,
            5
          ],
          "index": 2
        },
        "returns": 7
      },
      {
        "arguments": {
          "data": [
            "A",
            "B",
            "C"
          ],
          "index": 0
        },
        "returns": "A"
      },
      {
        "arguments": {
          "data": [],
          "index": 0,
          "return_nodata": true
        },
        "returns": null
      }
    ]
  },
  {
    "id": "arsinh",
    "summary": "Inverse hyperbolic sine",
    "description": "Computes the inverse hyperbolic sine of `x`. It is the inverse function of the hyperbolic sine so that *arsinh(sinh(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "process_graph": {
          "sinh1": {
            "process_id": "sinh",
            "arguments": {
              "x": 0.5
            }
          },
          "arcsinh1": {
            "process_id": "arsinh",
            "arguments": {
              "x": {
                "from_node": "sinh1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseHyperbolicSine.html",
        "title": "Inverse hyperbolic sine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "artanh",
    "summary": "Inverse hyperbolic tangent",
    "description": "Computes the inverse hyperbolic tangent of `x`. It is the inverse function of the hyperbolic tangent so that *artanh(tanh(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "process_graph": {
          "cosh1": {
            "process_id": "tanh",
            "arguments": {
              "x": 0.5
            }
          },
          "arctanh1": {
            "process_id": "artanh",
            "arguments": {
              "x": {
                "from_node": "tanh1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseHyperbolicTangent.html",
        "title": "Inverse hyperbolic tangent explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "between",
    "summary": "Between comparison",
    "description": "Checks whether `x` is greater than or equal to `min` and lower than or equal to `max` or to put it in simpler words checks whether `x` is between the lower bound `min` and the upper bound `max`. Therefore, this process is an alias for `and([gte(x, min), lte(x, max)])` and all definitions from these processes apply here as well.\n\nLower and upper bounds are not allowed to be swapped. So `min` MUST be lower than or equal to `max` or otherwise the process always returns `false`.",
    "categories": [
      "comparison"
    ],
    "parameter_order": [
      "x",
      "min",
      "max"
    ],
    "parameters": {
      "x": {
        "description": "",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "min": {
        "description": "Lower boundary (inclusive) to check against.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "max": {
        "description": "Upper boundary (inclusive) to check against.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if `x` is between the specified bounds, otherwise `false`.",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "x": null,
          "min": 0,
          "max": 1
        },
        "returns": null
      },
      {
        "description": "Swapped bounds (min is greater than max) MUST always return `false`.",
        "arguments": {
          "x": 0.5,
          "min": 1,
          "max": 0
        },
        "returns": false
      },
      {
        "arguments": {
          "x": -0.5,
          "min": 0,
          "max": -1
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "00:00:01+01:00",
          "min": "00:00:00Z",
          "max": "00:00:00+01:00"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2018-07-23T17:22:45Z",
          "min": "2018-01-01T00:00:00Z",
          "max": "2018-12-31T23:59:59Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2000-01-01",
          "min": "2018-01-01",
          "max": "2020-01-01"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "2018-12-31T17:22:45Z",
          "min": "2018-01-01",
          "max": "2018-12-31"
        },
        "returns": true
      }
    ]
  },
  {
    "id": "ceil",
    "summary": "Round fractions up",
    "description": "The least integer greater than or equal to the number `x`.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > rounding"
    ],
    "parameters": {
      "x": {
        "description": "A number to round up.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The number rounded up.",
      "schema": {
        "type": [
          "integer",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 4
      },
      {
        "arguments": {
          "x": -0.4
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": -3
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/CeilingFunction.html",
        "title": "Ceiling explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "clip",
    "summary": "Clips values between minimum and maximum values.",
    "description": "Clips an array of numbers between specified minimum and maximum values. All values larger than the maximal value will have the maximal value, all values lower than minimal value will have the minimal value.",
    "categories": [
      "math"
    ],
    "parameter_order": [
      "data",
      "min",
      "max"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "min": {
        "description": "Minimum value. All values lower than this value will be set to the value of this parameter.",
        "schema": {
          "type": "number"
        },
        "required": true
      },
      "max": {
        "description": "Maximum value. All values greater than this value will be set to the value of this parameter.",
        "schema": {
          "type": "number"
        },
        "required": true
      }
    },
    "returns": {
      "description": "An array with the values clipped to the specified range.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            -2,
            -1,
            0,
            1,
            2
          ],
          "min": -1,
          "max": 1
        },
        "returns": [
          -1,
          -1,
          0,
          1,
          1
        ]
      },
      {
        "arguments": {
          "data": [
            -0.1,
            -0.001,
            null,
            0,
            0.25,
            0.75,
            1.001,
            null
          ],
          "min": 0,
          "max": 1
        },
        "returns": [
          0,
          0,
          null,
          0,
          0.25,
          0.75,
          1,
          null
        ]
      }
    ]
  },
  {
    "id": "cos",
    "summary": "Cosine",
    "description": "Computes the cosine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed cosine of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 1
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Cosine.html",
        "title": "Cosine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "cosh",
    "summary": "Hyperbolic cosine",
    "description": "Computes the hyperbolic cosine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed hyperbolic cosine of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 1
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/HyperbolicCosine.html",
        "title": "Hyperbolic cosine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "count",
    "summary": "Count the number of elements",
    "description": "Gives the number of elements in an array that matches a certain criterion / expression.\n\n**Remarks:**\n\n* By default counts the number of valid elements. A valid element is every element for which ``is_valid()`` returns `true`.\n* To count all elements in a list set the `expression` parameter to boolean `true`.",
    "categories": [
      "arrays",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "expression"
    ],
    "parameters": {
      "data": {
        "description": "An array with elements of any type.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        },
        "required": true
      },
      "expression": {
        "description": "An expression that is evaluated against each element in the array. An element is counted only if the expression returns `true`. Defaults to count valid elements in a list (see ``is_valid()``). Setting this parameter to boolean `true` counts all elements in the list.",
        "schema": {
          "anyOf": [
            {
              "description": "An expression that is evaluated against each element in the array.",
              "type": "object",
              "format": "callback",
              "properties": {
                "value": {
                  "description": "A single value from the array. Any data type could be passed."
                }
              }
            },
            {
              "description": "Boolean `true` counts all elements in the list.",
              "type": "boolean",
              "const": true
            },
            {
              "description": "`null` counts valid elements in the list.",
              "type": "null"
            }
          ],
          "default": null
        }
      }
    },
    "returns": {
      "description": "The counted number of elements.",
      "schema": {
        "type": "number"
      }
    },
    "examples": [
      {
        "arguments": {
          "data": []
        },
        "returns": 0
      },
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 4
      },
      {
        "arguments": {
          "data": [
            "ABC",
            null
          ]
        },
        "returns": 1
      },
      {
        "arguments": {
          "data": [
            false,
            null
          ],
          "expression": true
        },
        "returns": 2
      },
      {
        "arguments": {
          "data": [
            0,
            1,
            2,
            3,
            4,
            5,
            null
          ],
          "expression": {
            "gt": {
              "process_id": "gt",
              "arguments": {
                "x": {
                  "from_argument": "element"
                },
                "y": 2
              },
              "result": true
            }
          }
        },
        "returns": 3
      }
    ]
  },
  {
    "id": "create_raster_cube",
    "summary": "Create an empty raster data cube",
    "description": "Creates a new raster data cube without dimensions.",
    "categories": [
      "cubes"
    ],
    "parameters": {},
    "returns": {
      "description": "An empty raster data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "cube_property",
    "summary": "Retrieve cube or dimension metadata",
    "description": "Gets metadata for a data cube or a dimension in the cube. To get metadata for a dimension specify the `dimension` parameter, otherwise set it to `null`.",
    "categories": [
      "cubes"
    ],
    "parameter_order": [
      "data",
      "name",
      "dimension"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "anyOf": [
            {
              "type": "object",
              "format": "raster-cube"
            },
            {
              "type": "object",
              "format": "vector-cube"
            }
          ]
        },
        "required": true
      },
      "name": {
        "description": "Name of the metadata property.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "dimension": {
        "description": "If required, a dimension name of the data cube.",
        "schema": {
          "type": [
            "string",
            "null"
          ],
          "default": null
        }
      }
    },
    "returns": {
      "description": "The value for the metadata property or `null` if no information are available.",
      "schema": {
        "description": "Any data type is allowed."
      }
    }
  },
  {
    "id": "cummax",
    "summary": "Cumulative maxima",
    "description": "Finds cumulative maxima of an array of numbers. Every computed element is equal to the bigger one between current element and previous element. The returned array and the input array have always the same length.\n\nBy default, no-data values are skipped, but stay in the result. Setting the `ignore_nodata` flag to `true` makes that once a no-data value / `null` is reached all following elements are set to `null` in the result.",
    "categories": [
      "math > cumulative"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is set for all the following elements.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "An array with the computed cumulative maxima.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            3,
            5,
            3,
            1
          ]
        },
        "returns": [
          1,
          3,
          5,
          5,
          5
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            3,
            null,
            5,
            1
          ]
        },
        "returns": [
          1,
          3,
          null,
          5,
          5
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            3,
            null,
            5,
            1
          ],
          "ignore_nodata": false
        },
        "returns": [
          1,
          3,
          null,
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "cummin",
    "summary": "Cumulative minima",
    "description": "Finds cumulative minima of an array of numbers. Every computed element is equal to the smaller one between current element and previous element. The returned array and the input array have always the same length.\n\nBy default, no-data values are skipped, but stay in the result. Setting the `ignore_nodata` flag to `true` makes that once a no-data value / `null` is reached all following elements are set to `null` in the result.",
    "categories": [
      "math > cumulative"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is set for all the following elements.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "An array with the computed cumulative minima.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            5,
            3,
            1,
            3,
            5
          ]
        },
        "returns": [
          5,
          3,
          1,
          1,
          1
        ]
      },
      {
        "arguments": {
          "data": [
            5,
            3,
            null,
            1,
            5
          ]
        },
        "returns": [
          5,
          3,
          null,
          1,
          1
        ]
      },
      {
        "arguments": {
          "data": [
            5,
            3,
            null,
            1,
            5
          ],
          "ignore_nodata": false
        },
        "returns": [
          5,
          3,
          null,
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "cumproduct",
    "summary": "Cumulative products",
    "description": "Computes cumulative products of an array of numbers. Every computed element is equal to the product of current and all previous values. The returned array and the input array have always the same length.\n\nBy default, no-data values are skipped, but stay in the result. Setting the `ignore_nodata` flag to `true` makes that once a no-data value / `null` is reached all following elements are set to `null` in the result.",
    "categories": [
      "math > cumulative"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is set for all the following elements.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "An array with the computed cumulative products.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            3,
            5,
            3,
            1
          ]
        },
        "returns": [
          1,
          3,
          15,
          45,
          45
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3,
            null,
            3,
            1
          ]
        },
        "returns": [
          1,
          2,
          6,
          null,
          18,
          18
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3,
            null,
            3,
            1
          ],
          "ignore_nodata": false
        },
        "returns": [
          1,
          2,
          6,
          null,
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "cumsum",
    "summary": "Cumulative sums",
    "description": "Computes cumulative sums of an array of numbers. Every computed element is equal to the sum of current and all previous values. The returned array and the input array have always the same length.\n\nBy default, no-data values are skipped, but stay in the result. Setting the `ignore_nodata` flag to `true` makes that once a no-data value / `null` is reached all following elements are set to `null` in the result.",
    "categories": [
      "math > cumulative"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is set for all the following elements.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "An array with the computed cumulative sums.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            3,
            5,
            3,
            1
          ]
        },
        "returns": [
          1,
          4,
          9,
          12,
          13
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            3,
            null,
            3,
            1
          ]
        },
        "returns": [
          1,
          4,
          null,
          7,
          8
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            3,
            null,
            3,
            1
          ],
          "ignore_nodata": false
        },
        "returns": [
          1,
          4,
          null,
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "debug",
    "summary": "Send debugging information to subscribed clients",
    "description": "Sends debugging information about the data to clients, which are subscribed to the topic `openeo.jobs.debug`.",
    "categories": [
      "development"
    ],
    "parameter_order": [
      "data",
      "id"
    ],
    "parameters": {
      "data": {
        "description": "Data to send.",
        "schema": {
          "description": "Any data type is allowed."
        },
        "required": true
      },
      "id": {
        "description": "An identifier to help identify the message in a bunch of other messages.",
        "schema": {
          "type": "string",
          "default": ""
        }
      }
    },
    "returns": {
      "description": "`false` if the information could not be sent, `true` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.0/apireference-subscriptions/#publish-openeojobsdebug",
        "title": "Information about the openEO API for Subscriptions"
      }
    ]
  },
  {
    "id": "divide",
    "summary": "Division of a sequence of numbers",
    "description": "Divides the first element in a sequential array of numbers by all other elements.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) so that for example a division by zero should result in infinity if the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nBy default no-data values are ignored. Setting `ignore_nodata` to `false` considers no-data values so that `null` is returned if any element is such a value.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers with at least two elements.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          },
          "minItems": 2
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed result of the sequence of numbers.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "exceptions": {
      "DivisorMissing": {
        "message": "Division requires at least two numbers (a dividend and one or more divisors)."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            15,
            5
          ]
        },
        "returns": 3
      },
      {
        "arguments": {
          "data": [
            -2,
            4,
            2.5
          ]
        },
        "returns": -0.2
      },
      {
        "arguments": {
          "data": [
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Division.html",
        "title": "Division explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "e",
    "summary": "Euler's number (e)",
    "description": "The real number *e* is a mathematical constant that is the base of the natural logarithm such that *ln(e) = 1*. The numerical value is approximately *2.71828*.",
    "categories": [
      "math > constants",
      "math > exponential & logarithmic"
    ],
    "parameters": {},
    "returns": {
      "description": "The numerical value of Euler's number.",
      "schema": {
        "type": "number"
      }
    },
    "examples": [
      {
        "title": "Test for ln(e) = 1",
        "process_graph": {
          "e1": {
            "process_id": "e",
            "arguments": {}
          },
          "ln1": {
            "process_id": "ln",
            "arguments": {
              "data": {
                "from_node": "e1"
              }
            },
            "result": true
          }
        },
        "returns": 1
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/e.html",
        "title": "Mathematical constant e explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "eq",
    "summary": "Equal to comparison",
    "description": "Compares whether `x` is strictly equal to `y`.\n\n**Remarks:**\n\n* Data types MUST be checked strictly, for example a string with the content *1* is not equal to the number *1*. Nevertheless, an integer *1* is equal to a floating point number *1.0* as `integer` is a sub-type of `number`.\n* If any of the operands is `null`, the return value is `null`.\n* Strings are expected to be encoded in UTF-8 by default.\n* Temporal strings MUST be compared differently than other strings and MUST NOT be compared based on their string representation due to different possible representations. For example, the UTC time zone representation `Z` has the same meaning as `+00:00`.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameter_order": [
      "x",
      "y",
      "delta",
      "case_sensitive"
    ],
    "parameters": {
      "x": {
        "description": "First operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "boolean"
            },
            {
              "type": "null"
            },
            {
              "type": "string"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "y": {
        "description": "Second operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "boolean"
            },
            {
              "type": "null"
            },
            {
              "type": "string"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "delta": {
        "description": "Only applicable for comparing two numbers. If this optional parameter is set to a positive non-zero number the equality of two numbers is checked against a delta value. This is especially useful to circumvent problems with floating point inaccuracy in machine-based computation.\n\nThis option is basically an alias for the following computation: `lte(abs(minus([x, y]), delta)`",
        "schema": {
          "type": [
            "number",
            "null"
          ],
          "default": null
        }
      },
      "case_sensitive": {
        "description": "Only applicable for comparing two strings. Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "Returns `true` if `x` is equal to `y`, `null` if any of the operands is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 1,
          "y": 1
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 1,
          "y": "1"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 1.02,
          "y": 1,
          "delta": 0.01
        },
        "returns": false
      },
      {
        "arguments": {
          "x": -1,
          "y": -1.001,
          "delta": 0.01
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 115,
          "y": 110,
          "delta": 10
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "Test",
          "y": "test"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "Test",
          "y": "test",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "",
          "y": "",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "00:00:00+00:00",
          "y": "00:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2018-01-01T12:00:00Z",
          "y": "2018-01-01T12:00:00"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "2018-01-01T00:00:00Z",
          "y": "2018-01-01Z01:00:00+01:00"
        },
        "returns": true
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.0/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      }
    ]
  },
  {
    "id": "exp",
    "summary": "Exponentiation to the base e",
    "description": "Exponential function to the base *e* raised to the power of `p`. This process is an alias for *e^p^* / `power(e(), p)`.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > exponential & logarithmic"
    ],
    "parameters": {
      "p": {
        "description": "The numerical exponent.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed value for *e* raised to the power of `p`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "p": 0
        },
        "returns": 1
      },
      {
        "arguments": {
          "p": null
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/ExponentialFunction.html",
        "title": "Exponential function explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "extrema",
    "summary": "Minimum and maximum values",
    "description": "Two element array containing the minimum and the maximum values of `data`.\n\nThis process is basically an alias for calling both ``min()`` and ``max()``, but may be implemented more performant by back-ends as it only needs to iterate over the data once instead of twice.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that an array with two `null` values is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "An array containing the minimum and maximum values for the specified numbers. The first element is the minimum, the second element is the maximum. If the input array is empty both elements are set to `null`.",
      "schema": {
        "anyOf": [
          {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "type": [
                "number"
              ]
            }
          },
          {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "type": [
                "null"
              ]
            }
          }
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": [
          0,
          3
        ]
      },
      {
        "arguments": {
          "data": [
            5,
            2.5,
            null,
            -0.7
          ]
        },
        "returns": [
          -0.7,
          5
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            null,
            2
          ],
          "ignore_nodata": false
        },
        "returns": [
          null,
          null
        ]
      },
      {
        "description": "The input array is empty: return two `null` values.",
        "arguments": {
          "data": []
        },
        "returns": [
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "filter_bands",
    "summary": "Filters the bands in the raster data cube.",
    "description": "",
    "categories": [
      "filter"
    ],
    "parameter_order": [
      "data",
      "bands"
    ],
    "parameters": {
      "data": {
        "description": "",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "bands": {
        "description": "",
        "schema": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "A data cube limited to a subset of its original bands. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "filter_bbox",
    "summary": "Filter spatially by bounding box",
    "description": "Limits the data cube to the specified bounding box.\n\nThe bounding box may include a vertical axis (see `base` and `height`).",
    "categories": [
      "filter"
    ],
    "parameter_order": [
      "data",
      "west",
      "south",
      "east",
      "north",
      "base",
      "height",
      "crs"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "west": {
        "description": "West (lower left corner, coordinate axis 1).",
        "schema": {
          "type": "number"
        },
        "required": true
      },
      "south": {
        "description": "South (lower left corner, coordinate axis 2).",
        "schema": {
          "type": "number"
        },
        "required": true
      },
      "east": {
        "description": "East (upper right corner, coordinate axis 1).",
        "schema": {
          "type": "number"
        },
        "required": true
      },
      "north": {
        "description": "North (upper right corner, coordinate axis 2).",
        "schema": {
          "type": "number"
        },
        "required": true
      },
      "base": {
        "description": "Base (optional, lower left corner, coordinate axis 3).",
        "schema": {
          "type": [
            "number",
            "null"
          ],
          "default": null
        }
      },
      "height": {
        "description": "Height (optional, upper right corner, coordinate axis 3).",
        "schema": {
          "type": [
            "number",
            "null"
          ],
          "default": null
        }
      },
      "crs": {
        "description": "Coordinate reference system. EPSG codes must be supported. In addition, proj4 strings should be supported by back-ends. Whenever possible, it is recommended to use EPSG codes instead of proj4 strings. Defaults to EPSG:4326 unless the client explicitly requests a different coordinate reference system.",
        "schema": {
          "type": "string",
          "default": "EPSG:4326"
        }
      }
    },
    "returns": {
      "description": "A data cube restricted to the bounding box. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "filter_geometry",
    "summary": "Filter spatially by geometry",
    "description": "Limits the data cube to the specified geometry..",
    "categories": [
      "filter"
    ],
    "parameter_order": [
      "data",
      "geometry"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "geometry": {
        "description": "A geometry, either a GeoJSON or a vector data cube.\n\nIf multiple geometries are passed, the intersection of all geometries is used as geometry.",
        "schema": {
          "anyOf": [
            {
              "type": "object",
              "format": "geojson"
            },
            {
              "type": "object",
              "format": "vector-cube"
            }
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "A data cube restricted to the specified geometry (or the intersection of geometries). Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "filter_property",
    "summary": "Filter based on metadata attributes",
    "description": "Limits the data cube to contain only data that matches against the specified expression. The attribute to match against is specified with the parameter `name`. See the Collection Discovery for potential attribute names.",
    "categories": [
      "filter"
    ],
    "parameter_order": [
      "data",
      "name",
      "expression"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "name": {
        "description": "Name of the attribute to filter on.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "expression": {
        "description": "Expression to evaluate against the attribute values.",
        "schema": {
          "type": "object",
          "format": "callback",
          "properties": {
            "x": {
              "description": "A value of any data type could be passed."
            }
          }
        },
        "required": true
      }
    },
    "returns": {
      "description": "A data cube with values restricted by a filter on its value's metadata attributes. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "filter_temporal",
    "summary": "Limits the data to the specified date range.",
    "description": "",
    "categories": [
      "filter"
    ],
    "parameter_order": [
      "data",
      "from",
      "to"
    ],
    "parameters": {
      "data": {
        "description": "",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "from": {
        "description": "",
        "schema": {
          "type": [
            "string",
            "null"
          ]
        },
        "required": true
      },
      "to": {
        "description": "",
        "schema": {
          "type": [
            "string",
            "null"
          ],
          "default": null
        }
      }
    },
    "returns": {
      "description": "A data cube restricted to the specified temporal extent. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "filter",
    "summary": "Filter based on a logical expression.",
    "description": "Filtering data based on a logical expression.",
    "categories": [
      "cubes",
      "filter"
    ],
    "parameter_order": [
      "data",
      "expression",
      "dimension"
    ],
    "parameters": {
      "data": {
        "description": "",
        "schema": {
          "anyOf": [
            {
              "type": "object",
              "format": "raster-cube"
            },
            {
              "type": "object",
              "format": "vector-cube"
            }
          ]
        },
        "required": true
      },
      "expression": {
        "description": "",
        "schema": {
          "type": "object",
          "format": "callback",
          "properties": {
            "value": {
              "description": "A value of any data type could be passed."
            }
          }
        },
        "required": true
      },
      "dimension": {
        "description": "",
        "schema": {
          "type": "string"
        },
        "required": true
      }
    },
    "returns": {
      "description": "A data cube restricted by the specified expression. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "anyOf": [
          {
            "type": "object",
            "format": "raster-cube"
          },
          {
            "type": "object",
            "format": "vector-cube"
          }
        ]
      }
    }
  },
  {
    "id": "find_collections",
    "summary": "Search for collections by metadata properties",
    "description": "**EXPERIMENTAL.** Searches for collections available on the current back-end by metadata properties and returns ids of collections that match all criteria. ``cube_property()`` can be used to get property values.\n\nA single collection can be selected using array operations such as ``first()``, ``last()`` and ``array_element()`` and afterwards be loaded using ``load_collection()``.",
    "categories": [
      "cubes",
      "import"
    ],
    "parameters": {
      "expression": {
        "description": "An expression that is evaluated against each collection the back-end offers.",
        "schema": {
          "type": "object",
          "format": "callback",
          "properties": {
            "data": {
              "description": "A data cube.",
              "anyOf": [
                {
                  "type": "object",
                  "format": "raster-cube"
                },
                {
                  "type": "object",
                  "format": "vector-cube"
                }
              ]
            }
          }
        },
        "required": true
      }
    },
    "returns": {
      "description": "An array of matching collection ids.",
      "schema": {
        "type": "array",
        "items": {
          "description": "Each element is a job id.",
          "type": "string",
          "pattern": "^[A-Za-z0-9_\\-\\.~/]+$"
        }
      }
    }
  },
  {
    "id": "first",
    "summary": "First element",
    "description": "Gives the first element of an array. For an empty array `null` is returned.",
    "categories": [
      "arrays",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array with elements of any type. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if the first value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The first element of the input array.",
      "schema": {
        "description": "Any data type is allowed."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 1
      },
      {
        "arguments": {
          "data": [
            null,
            "A",
            "B"
          ]
        },
        "returns": "A"
      },
      {
        "arguments": {
          "data": [
            null,
            2,
            3
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ]
  },
  {
    "id": "floor",
    "summary": "Round fractions down",
    "description": "The greatest integer less than or equal to the number `x`.\n\nThis process is *not* an alias for the `int` process as defined by some mathematicians, see the examples for negative numbers in both processes for differences.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > rounding"
    ],
    "parameters": {
      "x": {
        "description": "A number to round down.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The number rounded down.",
      "schema": {
        "type": [
          "integer",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 3
      },
      {
        "arguments": {
          "x": -0.4
        },
        "returns": -1
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": -4
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/FloorFunction.html",
        "title": "Floor explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "gt",
    "summary": "Greater than comparison",
    "description": "Compares whether `x` is strictly greater than `y`.\n\n**Remarks:**\n\n* If any of the operands is `null`, the return value is `null`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.\n* Comparing strings is currently not supported, but is planned to be added in the future.",
    "categories": [
      "comparison"
    ],
    "parameter_order": [
      "x",
      "y"
    ],
    "parameters": {
      "x": {
        "description": "First operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "y": {
        "description": "Second operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if `x` is strictly greater than `y` or `null` if any of the operands is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 0,
          "y": 0
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 2,
          "y": 1
        },
        "returns": true
      },
      {
        "arguments": {
          "x": -0.5,
          "y": -0.6
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "00:00:00Z",
          "y": "00:00:00+01:00"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "1950-01-01T00:00:00Z",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "2018-01-01T12:00:00+00:00",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": false
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.0/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      }
    ]
  },
  {
    "id": "gte",
    "summary": "Greater than or equal to comparison",
    "description": "Compares whether `x` is greater than or equal to `y`.\n\n**Remarks:**\n\n* If any of the operands is `null`, the return value is `null`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.\n* Comparing strings is currently not supported, but is planned to be added in the future.",
    "categories": [
      "comparison"
    ],
    "parameter_order": [
      "x",
      "y"
    ],
    "parameters": {
      "x": {
        "description": "First operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "y": {
        "description": "Second operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if `x` is greater than or equal to `y` or `null` if any of the operands is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 0,
          "y": 0
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 1,
          "y": 2
        },
        "returns": false
      },
      {
        "arguments": {
          "x": -0.5,
          "y": -0.6
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "00:00:00Z",
          "y": "00:00:00+01:00"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "1950-01-01T00:00:00Z",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "2018-01-01T12:00:00+00:00",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": true
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.0/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      }
    ]
  },
  {
    "id": "if",
    "summary": "If-Then-Else conditional",
    "description": "Returns the value of the `accept` parameter if the expression is `true` or the value of the `reject` parameter if the expression is `false`. This works similar to an if-then-else construct.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "logic",
      "comparison",
      "masks"
    ],
    "parameter_order": [
      "expression",
      "accept",
      "reject"
    ],
    "parameters": {
      "expression": {
        "description": "A boolean value.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ]
        },
        "required": true
      },
      "accept": {
        "description": "A value that is returned if the boolean expression is `true`. Defaults to `true`.",
        "schema": {
          "description": "Any data type is allowed.",
          "default": true
        }
      },
      "reject": {
        "description": "A value that is returned if the boolean expression is `false`. Defaults to `false`.",
        "schema": {
          "description": "Any data type is allowed.",
          "default": false
        }
      }
    },
    "returns": {
      "description": "Either the `accept` or `reject` argument depending on the given boolean expression.",
      "schema": {
        "description": "Any data type is allowed."
      }
    },
    "examples": [
      {
        "arguments": {
          "expression": true
        },
        "returns": true
      },
      {
        "arguments": {
          "expression": null
        },
        "returns": null
      },
      {
        "arguments": {
          "expression": false
        },
        "returns": false
      },
      {
        "arguments": {
          "expression": true,
          "accept": "A"
        },
        "returns": "A"
      },
      {
        "arguments": {
          "expression": false,
          "accept": [
            1,
            2,
            3
          ],
          "reject": [
            4,
            5,
            6
          ]
        },
        "returns": [
          4,
          5,
          6
        ]
      }
    ]
  },
  {
    "id": "int",
    "summary": "Integer part of a number",
    "description": "The integer part of the real number `x`.\n\nThis process is *not* an alias for the `floor` process as defined by some mathematicians, see the examples for negative numbers in both processes for differences.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math",
      "math > rounding"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "Integer part of the number.",
      "schema": {
        "type": [
          "integer",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 3
      },
      {
        "arguments": {
          "x": -0.4
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": -3
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/IntegerPart.html",
        "title": "Integer Part explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "is_nan",
    "summary": "Value is not a number",
    "description": "Checks whether the specified value `x` is not a number (often abbreviated as `NaN`). The definition of `NaN` follows the [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935). All non-numeric data types MUST also return `false`.",
    "categories": [
      "comparison"
    ],
    "parameters": {
      "x": {
        "description": "The data to check.",
        "schema": {
          "description": "Any data type is allowed."
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if the data is not a number, otherwise `false`",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "Test"
        },
        "returns": false
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "is_nodata",
    "summary": "Value is not a no-data value",
    "description": "Checks whether the specified data is a missing data, i.e. equals to one of the no-data values / `null`.",
    "categories": [
      "comparison"
    ],
    "parameters": {
      "x": {
        "description": "The data to check.",
        "schema": {
          "description": "Any data type is allowed."
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if the data is a no-data value, otherwise `false`",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "Test"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": null
        },
        "returns": true
      }
    ]
  },
  {
    "id": "is_valid",
    "summary": "Value is valid data",
    "description": "Checks whether the specified value `x` is valid. A value is considered valid if it is\n\n1. not a no-data value (`null`) and\n2. a finite number (only if `x` is a number). The definition of finite and infinite numbers follows the [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935).",
    "categories": [
      "comparison"
    ],
    "parameters": {
      "x": {
        "description": "The data to check.",
        "schema": {
          "description": "Any data type is allowed."
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if the data is valid, otherwise `false`.",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "Test"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": null
        },
        "returns": false
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "last",
    "summary": "Last element",
    "description": "Gives the last element of an array. For an empty array `null` is returned.",
    "categories": [
      "arrays",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array with elements of any type. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if the last value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The last element of the input array.",
      "schema": {
        "description": "Any data type is allowed."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 2
      },
      {
        "arguments": {
          "data": [
            "A",
            "B",
            null
          ]
        },
        "returns": "B"
      },
      {
        "arguments": {
          "data": [
            0,
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ]
  },
  {
    "id": "linear_scale_range",
    "summary": "Linear transformation between two ranges",
    "description": "Performs a linear transformation between the input and output range.\n\nThe underlying formula is: `((x - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin`.\n\nPotential use case include\n\n* scaling values to the 8-bit range (0 - 255) often used for numeric representation of values in one of the channels of the [RGB colour model](https://en.wikipedia.org/wiki/RGB_color_model#Numeric_representations) or\n* calculating percentages (0 - 100).\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math"
    ],
    "parameter_order": [
      "x",
      "inputMin",
      "inputMax",
      "outputMin",
      "outputMax"
    ],
    "parameters": {
      "x": {
        "description": "A number to transform.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      },
      "inputMin": {
        "description": "Minimum value the input can obtain.",
        "schema": {
          "type": "number"
        },
        "required": true
      },
      "inputMax": {
        "description": "Maximum value the input can obtain.",
        "schema": {
          "type": "number"
        },
        "required": true
      },
      "outputMin": {
        "description": "Minimum value of the desired output range.",
        "schema": {
          "type": "number",
          "default": 0
        }
      },
      "outputMax": {
        "description": "Maximum value of the desired output range.",
        "schema": {
          "type": "number",
          "default": 1
        }
      }
    },
    "returns": {
      "description": "The transformed number.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0.3,
          "inputMin": -1,
          "inputMax": 1,
          "outputMin": 0,
          "outputMax": 255
        },
        "returns": 165.75
      },
      {
        "arguments": {
          "x": 25.5,
          "inputMin": 0,
          "inputMax": 255
        },
        "returns": 0.1
      },
      {
        "arguments": {
          "x": null,
          "inputMin": 0,
          "inputMax": 100
        },
        "returns": null
      }
    ]
  },
  {
    "id": "ln",
    "summary": "Natural logarithm",
    "description": "The natural logarithm is the logarithm to the base *e* of the number `x`. This process is an alias for the *log* process with the base set to *e*: `log(x, e())`. The natural logarithm is the inverse function of taking *e* to the power x.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) so that for example `ln(0)` should result in infinity if the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > exponential & logarithmic"
    ],
    "parameters": {
      "x": {
        "description": "A number to compute the natural logarithm for.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed natural logarithm.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "title": "Example for ln(e) = 1",
        "process_graph": {
          "e1": {
            "process_id": "e",
            "arguments": {}
          },
          "ln1": {
            "process_id": "ln",
            "arguments": {
              "data": {
                "from_node": "e1"
              }
            },
            "result": true
          }
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 1
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/NaturalLogarithm.html",
        "title": "Natural logarithm explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "load_collection",
    "summary": "Load a collection",
    "description": "Loads a collection from the current back-end by its id and returns it as processable data cube.",
    "categories": [
      "cubes",
      "import"
    ],
    "parameters": {
      "id": {
        "description": "The collection id.",
        "schema": {
          "type": "string",
          "pattern": "^[A-Za-z0-9_\\-\\.~/]+$"
        },
        "required": true
      }
    },
    "returns": {
      "description": "A data cube for further processing.",
      "schema": {
        "anyOf": [
          {
            "type": "object",
            "format": "raster-cube"
          },
          {
            "type": "object",
            "format": "vector-cube"
          }
        ]
      }
    }
  },
  {
    "id": "load_result",
    "summary": "Load batch job results",
    "description": "Loads locally stored batch job results by job id. The job must have been stored by the authenticated user on the back-end currently connected to.",
    "categories": [
      "cubes",
      "import"
    ],
    "parameters": {
      "id": {
        "description": "The id of a batch job with results.",
        "schema": {
          "type": "string",
          "pattern": "^[A-Za-z0-9_\\-\\.~]+$"
        },
        "required": true
      }
    },
    "returns": {
      "description": "A data cube for further processing.",
      "schema": {
        "anyOf": [
          {
            "type": "object",
            "format": "raster-cube"
          },
          {
            "type": "object",
            "format": "vector-cube"
          }
        ]
      }
    }
  },
  {
    "id": "log",
    "summary": "Logarithm to a base",
    "description": "Logarithm to the base `base` of the number `x` is defined to be the inverse function of taking b to the power of x.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) so that for example `log(0, 2)` should result in infinity if the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nThe no-data value `null` is passed through and therefore gets propagated if any of the arguments is `null`.",
    "categories": [
      "math > exponential & logarithmic"
    ],
    "parameter_order": [
      "x",
      "base"
    ],
    "parameters": {
      "x": {
        "description": "A number to compute the logarithm for.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      },
      "base": {
        "description": "The numerical base.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed logarithm.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 10,
          "base": 10
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 2,
          "base": 2
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 4,
          "base": 2
        },
        "returns": 2
      },
      {
        "arguments": {
          "x": 1,
          "base": 16
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Logarithm.html",
        "title": "Logarithm explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "lt",
    "summary": "Less than comparison",
    "description": "Compares whether `x` is strictly less than `y`.\n\n**Remarks:**\n\n* If any of the operands is `null`, the return value is `null`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.\n* Comparing strings is currently not supported, but is planned to be added in the future.",
    "categories": [
      "comparison"
    ],
    "parameter_order": [
      "x",
      "y"
    ],
    "parameters": {
      "x": {
        "description": "First operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "y": {
        "description": "Second operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if `x` is strictly less than `y`, `null` if any of the operands is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 0,
          "y": 0
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 1,
          "y": 2
        },
        "returns": true
      },
      {
        "arguments": {
          "x": -0.5,
          "y": -0.6
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "00:00:00+01:00",
          "y": "00:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "1950-01-01T00:00:00Z",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2018-01-01T12:00:00+00:00",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": false
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.0/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      }
    ]
  },
  {
    "id": "lte",
    "summary": "Less than or equal to comparison",
    "description": "Compares whether `x` is less than or equal to `y`.\n\n**Remarks:**\n\n* If any of the operands is `null`, the return value is `null`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.\n* Comparing strings is currently not supported, but is planned to be added in the future.",
    "categories": [
      "comparison"
    ],
    "parameter_order": [
      "x",
      "y"
    ],
    "parameters": {
      "x": {
        "description": "First operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "y": {
        "description": "Second operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if `x` is less than or equal to `y`, `null` if any of the operands is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 0,
          "y": 0
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 1,
          "y": 2
        },
        "returns": true
      },
      {
        "arguments": {
          "x": -0.5,
          "y": -0.6
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "00:00:00+01:00",
          "y": "00:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "1950-01-01T00:00:00Z",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2018-01-01T12:00:00+00:00",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": true
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.0/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      }
    ]
  },
  {
    "id": "mask",
    "summary": "Apply a mask",
    "description": "Applies a mask to a raster data cube. Therefore, compares the parallel elements of the raster data cubes specified for `data` and `mask` and replaces all elements in `data` that are non-zero (for numbers) or `true` (for boolean values) in `mask`. These elements are replaced with the value specified for `replacement`, which defaults to `null` (no data). No data values will be left untouched.",
    "categories": [
      "masks"
    ],
    "parameter_order": [
      "data",
      "mask",
      "replacement"
    ],
    "parameters": {
      "data": {
        "description": "A raster data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "mask": {
        "description": "A compatible raster data cube so that every element in `data` has a parallel element in the data cube specified here.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "replacement": {
        "description": "The value used to replace non-zero and `true` values with.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "boolean"
            },
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      }
    },
    "returns": {
      "description": "The masked raster data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "max",
    "summary": "Maximum value",
    "description": "Computes the largest value of an array of numbers, which is is equal to the first element of a sorted (i.e., ordered) version the array.",
    "categories": [
      "arrays",
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The maximum value.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 3
      },
      {
        "arguments": {
          "data": [
            5,
            2.5,
            null,
            -0.7
          ]
        },
        "returns": 5
      },
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            null,
            2
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Maximum.html",
        "title": "Maximum explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "mean",
    "summary": "Arithmetic mean (average)",
    "description": "The arithmetic mean of an array of numbers is the quantity commonly called the average. It is defined as the sum of all elements divided by the number of elements.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed arithmetic mean.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 1.5
      },
      {
        "arguments": {
          "data": [
            9,
            2.5,
            null,
            -2.5
          ]
        },
        "returns": 3
      },
      {
        "arguments": {
          "data": [
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/ArithmeticMean.html",
        "title": "Arithmetic mean explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "median",
    "summary": "Statistical median",
    "description": "The statistical median of an array of numbers is the value separating the higher half from the lower half of the data.\n\n**Remarks:**\n\n* For a symmetric arrays, the result is equal to the ``mean()``.\n* The median can also be calculated by computing the quantile (see process ``quantiles()``) with the probability of *0.5*: `quantiles(data, [0.5])`.\n* An empty input array returns `null`.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed statistical median.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            3,
            3,
            6,
            7,
            8,
            9
          ]
        },
        "returns": 6
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3,
            4,
            5,
            6,
            8,
            9
          ]
        },
        "returns": 4.5
      },
      {
        "arguments": {
          "data": [
            -1,
            -0.5,
            null,
            1
          ]
        },
        "returns": -0.5
      },
      {
        "arguments": {
          "data": [
            -1,
            0,
            null,
            1
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/StatisticalMedian.html",
        "title": "Statistical Median explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "merge_cubes",
    "summary": "Merging two data cubes",
    "description": "The data cubes have to be compatible. A merge is the inverse of a split if there is no overlap. If data overlaps the overlap resolver must be specified to resolve the overlap. It doesn't add dimensions.",
    "categories": [
      "cubes"
    ],
    "parameter_order": [
      "cube1",
      "cube2",
      "overlap_resolver"
    ],
    "parameters": {
      "cube1": {
        "description": "The first data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "cube2": {
        "description": "The second data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "overlap_resolver": {
        "description": "An overlap resolver if the data overlaps. It must be process that is able to reduce the values available in the data cubes to a single value. So the specified process must be a reducer that accepts an array and computes a single return value of the same type as the input values for it, for example ``median()``.",
        "schema": {
          "type": "object",
          "format": "callback",
          "properties": {
            "overlap": {
              "description": "An array with elements of any type.",
              "type": "array",
              "items": {
                "description": "Any data type."
              }
            }
          }
        }
      }
    },
    "returns": {
      "description": "The merged data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "exceptions": {
      "OverlapResolverMissing": {
        "message": "Two data cubes with overlap but without an overlap resolver have been specified."
      }
    }
  },
  {
    "id": "min",
    "summary": "Minimum value",
    "description": "Computes the smallest value of an array of numbers, which is is equal to the last element of a sorted (i.e., ordered) version the array.",
    "categories": [
      "arrays",
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The minimum value.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": [
          0,
          3
        ]
      },
      {
        "arguments": {
          "data": [
            5,
            2.5,
            null,
            -0.7
          ]
        },
        "returns": [
          -0.7,
          5
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            null,
            2
          ],
          "ignore_nodata": false
        },
        "returns": [
          null,
          null
        ]
      },
      {
        "description": "The input array is empty: return two `null` values.",
        "arguments": {
          "data": []
        },
        "returns": [
          null,
          null
        ]
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Minimum.html",
        "title": "Minimum explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "mod",
    "summary": "Modulo",
    "description": "Remainder after division of `x` by `y`.\n\nThe result of a modulo operation has the sign of the divisor. The handling regarding the sign of the result [differs between programming languages](https://en.wikipedia.org/wiki/Modulo_operation) and needs careful consideration while implementing this process.\n\nThe no-data value `null` is passed through and therefore gets propagated if any of the arguments is `null`.",
    "categories": [
      "math"
    ],
    "parameter_order": [
      "x",
      "y"
    ],
    "parameters": {
      "x": {
        "description": "A number to be used as dividend.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      },
      "y": {
        "description": "A number to be used as divisor.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The remainder after division.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 27,
          "y": 5
        },
        "returns": 2
      },
      {
        "arguments": {
          "x": -27,
          "y": 5
        },
        "returns": 3
      },
      {
        "arguments": {
          "x": 27,
          "y": -5
        },
        "returns": -3
      },
      {
        "arguments": {
          "x": -27,
          "y": -5
        },
        "returns": -2
      },
      {
        "arguments": {
          "x": 27,
          "y": 5
        },
        "returns": 2
      },
      {
        "arguments": {
          "x": 27,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": null,
          "y": 5
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Modulo_operation",
        "title": "Modulo explained by Wikipedia"
      }
    ]
  },
  {
    "id": "multiply",
    "summary": "Multiplication of a sequence of numbers",
    "description": "Multiplies all elements in a sequential array of numbers and returns the computed product.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) whenever the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nBy default no-data values are ignored. Setting `ignore_nodata` to `false` considers no-data values so that `null` is returned if any element is such a value.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers with at least two elements.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          },
          "minItems": 2
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed product of the sequence of numbers.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "exceptions": {
      "MultiplicandMissing": {
        "message": "Multiplication requires at least two numbers."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            5,
            0
          ]
        },
        "returns": 0
      },
      {
        "arguments": {
          "data": [
            -2,
            4,
            2.5
          ]
        },
        "returns": -20
      },
      {
        "arguments": {
          "data": [
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Product.html",
        "title": "Product explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "NDVI",
    "summary": "Normalized Difference Vegetation Index",
    "description": "Computes the Normalized Difference Vegetation Index (NDVI). The NDVI is computed as *(nir - red) / (nir + red)*.\n\nThe `data` parameter expects a raster data cube with two bands that have the common names `red` and `nir` assigned. The process returns a raster data cube with two bands being replaced with a new band that holds the computed values. The newly created band is named `ndvi` by default. This name can be changed with the `name` parameter.\n\nThis process is very similar to the process ``normalized_difference()``, but determines the bands automatically based on the common name (`red`/`nir`) specified in the metadata.",
    "categories": [
      "math > indices",
      "vegetation indices"
    ],
    "parameter_order": [
      "data",
      "name"
    ],
    "parameters": {
      "data": {
        "description": "A raster data cube with two bands that have the common names `red` and `nir` assigned.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "name": {
        "description": "Name of the newly created band with the computed values. Defaults to `normalized_difference`.",
        "schema": {
          "type": "string",
          "default": "normalized_difference",
          "pattern": "^[A-Za-z0-9_]+$"
        }
      }
    },
    "returns": {
      "description": "A raster data cube with the two bands being replaced with a new band that holds the computed values.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Normalized_difference_vegetation_index",
        "title": "NDVI explained by Wikipedia"
      },
      {
        "rel": "about",
        "href": "https://earthobservatory.nasa.gov/features/MeasuringVegetation/measuring_vegetation_2.php",
        "title": "NDVI explained by NASA"
      }
    ]
  },
  {
    "id": "neq",
    "summary": "Not equal to comparison",
    "description": "Compares whether `x` is *not* strictly equal to `y`. This process is an alias for: `not(eq(val1, val2))`.\n\n**Remarks:**\n\n* Data types MUST be checked strictly, for example a string with the content *1* is not equal to the number *1*. Nevertheless, an integer *1* is equal to a floating point number *1.0* as `integer` is a sub-type of `number`.\n* If any of the operands is `null`, the return value is `null`.\n* Strings are expected to be encoded in UTF-8 by default.\n* Temporal strings MUST be compared differently than other strings and MUST NOT be compared based on their string representation due to different possible representations. For example, the UTC time zone representation `Z` has the same meaning as `+00:00`.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameter_order": [
      "x",
      "y",
      "delta",
      "case_sensitive"
    ],
    "parameters": {
      "x": {
        "description": "First operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "boolean"
            },
            {
              "type": "null"
            },
            {
              "type": "string"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "y": {
        "description": "Second operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "boolean"
            },
            {
              "type": "null"
            },
            {
              "type": "string"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "delta": {
        "description": "Only applicable for comparing two numbers. If this optional parameter is set to a positive non-zero number the non-equality of two numbers is checked against a delta value. This is especially useful to circumvent problems with floating point inaccuracy in machine-based computation.\n\nThis option is basically an alias for the following computation: `gt(abs(minus([x, y]), delta)`",
        "schema": {
          "type": [
            "number",
            "null"
          ],
          "default": null
        }
      },
      "case_sensitive": {
        "description": "Only applicable for comparing two strings. Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "Returns `true` if `x` is *not* equal to `y`, `null` if any of the operands is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 1,
          "y": 1
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 1,
          "y": "1"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 1.02,
          "y": 1,
          "delta": 0.01
        },
        "returns": true
      },
      {
        "arguments": {
          "x": -1,
          "y": -1.001,
          "delta": 0.01
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 115,
          "y": 110,
          "delta": 10
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "Test",
          "y": "test"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "Test",
          "y": "test",
          "case_sensitive": false
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "",
          "y": "",
          "case_sensitive": false
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "00:00:00+00:00",
          "y": "00:00:00Z"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "2018-01-01T12:00:00Z",
          "y": "2018-01-01T12:00:00"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2018-01-01T00:00:00Z",
          "y": "2018-01-01Z01:00:00+01:00"
        },
        "returns": false
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.0/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      }
    ]
  },
  {
    "id": "normalized_difference",
    "summary": "Normalized difference for two bands",
    "description": "Computes the normalized difference for two bands. The normalized difference is computed as *(band1 - band2) / (band1 + band2)*.\n\nEach of the parameters expects a raster data cube with exactly one band. The process returns a raster data cube with exactly one band that holds the computed values. The newly created band is named `normalized_difference` by default. This name can be changed with the `name` parameter.\n\nThis process could be used for a number of remote sensing indices such as:\n\n* [NDVI](https://eos.com/ndvi/)\n* [NDWI](https://eos.com/ndwi/)\n* [NDSI](https://eos.com/ndsi/)\n\nPlease note that some back-ends may have native processes available for convenience such as the ``NDVI()``.",
    "categories": [
      "math > indices",
      "vegetation indices"
    ],
    "parameter_order": [
      "band1",
      "band2",
      "name"
    ],
    "parameters": {
      "band1": {
        "description": "A raster data cube with exactly one band to be used as first band.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "band2": {
        "description": "A raster data cube with exactly one band to be used as second band.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "name": {
        "description": "Name of the newly created band with the computed values. Defaults to `normalized_difference`.",
        "schema": {
          "type": "string",
          "default": "normalized_difference",
          "pattern": "^[A-Za-z0-9_]+$"
        }
      }
    },
    "returns": {
      "description": "A raster data cube with exactly one band that holds the computed values.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "links": [
      {
        "rel": "related",
        "href": "https://eos.com/ndvi/",
        "title": "NDVI explained by EOS"
      },
      {
        "rel": "related",
        "href": "https://eos.com/ndwi/",
        "title": "NDWI explained by EOS"
      },
      {
        "rel": "related",
        "href": "https://eos.com/ndsi/",
        "title": "NDSI explained by EOS"
      }
    ]
  },
  {
    "id": "not",
    "summary": "Inverting a boolean",
    "description": "Inverts a single boolean so that `true` gets `false` and `false` gets `true`.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "logic"
    ],
    "parameters": {
      "expression": {
        "description": "Boolean value to invert.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "Inverted boolean value.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "expression": null
        },
        "returns": null
      },
      {
        "arguments": {
          "expression": false
        },
        "returns": true
      },
      {
        "arguments": {
          "expression": true
        },
        "returns": false
      }
    ]
  },
  {
    "id": "or",
    "summary": "Is at least one value true?",
    "description": "Checks if **at least one** of the values is true. Evaluates each expression from the first to the last element and stops once the outcome is unambiguous.\n\nIf only one value is given the process evaluates to the given value. If no value is given (i.e. the array is empty) the process returns `null`.\n\nBy default all no-data values are ignored so that the process returns `true` if at least one of the other values is true and otherwise returns `false`.\nSetting the `ignore_nodata` flag to `false` considers no-data values so that `null` is a valid logical object. If a component is `null`, the result will be `null` if the outcome is ambiguous. See the following truth table:\n\n```\n      || null | false | true\n----- || ---- | ----- | ----\nnull  || null | null  | true\nfalse || null | false | true\ntrue  || true | true  | true\n```",
    "categories": [
      "logic",
      "reducer"
    ],
    "parameter_order": [
      "expressions",
      "ignore_nodata"
    ],
    "parameters": {
      "expressions": {
        "description": "A set of boolean values.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "boolean",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not and ignores them by default.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "Boolean result of the logical expressions.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "expressions": [
            false,
            null
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true,
            null
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            false,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "expressions": [
            true,
            null
          ],
          "ignore_nodata": false
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            true,
            false,
            true,
            false
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            true,
            false
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            false,
            false
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": []
        },
        "returns": null
      }
    ]
  },
  {
    "id": "order",
    "summary": "Create a permutation",
    "description": "Computes a permutation which allows rearranging the data into ascending or descending order. In other words, this process computes the ranked (sorted) element positions in the original list.\n\n**Remarks:**\n\n* The positions in the result are zero-based.\n* Ties will be left in their original ordering.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.",
    "categories": [
      "arrays",
      "sorting"
    ],
    "parameter_order": [
      "data",
      "asc",
      "nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array to compute the order for.",
        "schema": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "string",
                "format": "date"
              },
              {
                "type": "string",
                "format": "time"
              }
            ]
          }
        },
        "required": true
      },
      "asc": {
        "description": "The default sort order is ascending, with smallest values first. To sort in reverse (descending) order, set this parameter to `false`.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      },
      "nodata": {
        "description": "Controls the handling of no-data values (`null`). By default they are removed. If `true`, missing values in the data are put last; if `false`, they are put first.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ],
          "default": null
        }
      }
    },
    "returns": {
      "description": "The computed permutation.",
      "schema": {
        "type": "array",
        "items": {
          "type": "integer",
          "minimum": 0
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ]
        },
        "returns": [
          1,
          2,
          8,
          5,
          0,
          4,
          7,
          9,
          10
        ]
      },
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ],
          "nodata": true
        },
        "returns": [
          1,
          2,
          8,
          5,
          0,
          4,
          7,
          9,
          10,
          3,
          6
        ]
      },
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ],
          "asc": false,
          "nodata": true
        },
        "returns": [
          9,
          10,
          7,
          4,
          0,
          5,
          8,
          2,
          1,
          3,
          6
        ]
      },
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ],
          "asc": false,
          "nodata": false
        },
        "returns": [
          3,
          6,
          9,
          10,
          7,
          4,
          0,
          5,
          8,
          2,
          1
        ]
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.0/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      },
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Permutation.html",
        "title": "Permutation explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "output",
    "summary": "Send data to subscribed clients",
    "description": "Outputs the data to clients, which are subscribed to the topic `openeo.jobs.output`.",
    "categories": [
      "development"
    ],
    "parameter_order": [
      "data",
      "id"
    ],
    "parameters": {
      "data": {
        "description": "Data to send.",
        "schema": {
          "description": "Any data type is allowed."
        },
        "required": true
      },
      "id": {
        "description": "An identifier to help identify the message in a bunch of other messages.",
        "schema": {
          "type": "string",
          "default": ""
        }
      }
    },
    "returns": {
      "description": "`false` if the information could not be sent, `true` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.0/apireference-subscriptions/#publish-openeojobsoutput",
        "title": "Information about the openEO API for Subscriptions"
      }
    ]
  },
  {
    "id": "pi",
    "summary": "Pi ()",
    "description": "The real number Pi () is a mathematical constant that is the ratio of the circumference of a circle to its diameter. The numerical value is approximately *3.14159*.",
    "categories": [
      "math > constants",
      "math > trigonometric"
    ],
    "parameters": {},
    "returns": {
      "description": "The numerical value of Pi.",
      "schema": {
        "type": "number"
      }
    },
    "examples": [
      {
        "title": "Test for sin() = 0",
        "process_graph": {
          "pi1": {
            "process_id": "pi",
            "arguments": {}
          },
          "sin1": {
            "process_id": "sin",
            "arguments": {
              "data": {
                "from_node": "pi1"
              }
            },
            "result": true
          }
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Pi.html",
        "title": "Mathematical constant Pi explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "power",
    "summary": "Exponentiation",
    "description": "Computes the exponentiation for the base `base` raised to the power of `p`.\n\nThe no-data value `null` is passed through and therefore gets propagated if any of the arguments is `null`.",
    "categories": [
      "math",
      "math > exponential & logarithmic"
    ],
    "parameter_order": [
      "base",
      "p"
    ],
    "parameters": {
      "base": {
        "description": "The numerical base.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      },
      "p": {
        "description": "The numerical exponent.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed value for `base` raised to the power of `p`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "base": 0,
          "p": 2
        },
        "returns": 0
      },
      {
        "arguments": {
          "base": 2.5,
          "p": 0
        },
        "returns": 1
      },
      {
        "arguments": {
          "base": 3,
          "p": 3
        },
        "returns": 27
      },
      {
        "arguments": {
          "base": 5,
          "p": -1
        },
        "returns": 0.2
      },
      {
        "arguments": {
          "base": 1,
          "p": 0.5
        },
        "returns": 1
      },
      {
        "arguments": {
          "base": 1,
          "p": null
        },
        "returns": null
      },
      {
        "arguments": {
          "base": null,
          "p": 2
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Power.html",
        "title": "Power explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "product",
    "summary": "Multiplication of a sequence of numbers",
    "description": "This process is an exact alias for the `multiply` process. See ``multiply()`` for more information.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "See ``multiply()`` for more information.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "See ``multiply()`` for more information.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "See ``multiply()`` for more information.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    }
  },
  {
    "id": "quantiles",
    "summary": "Quantiles",
    "description": "Calculates quantiles, which are cut points dividing the range of a probability distribution into either\n\n* intervals corresponding to the given `probabilities` or\n* (nearly) equal-sized intervals (q-quantiles based on the parameter `q`).\n\nEither the parameter `probabilites` or `q` must be specified, otherwise the `QuantilesParameterMissing` exception must be thrown. If both parameters are set the `QuantilesParameterConflict` exception must be thrown.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "probabilities",
      "q",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "probabilities": {
        "description": "A list of probabilities to calculate quantiles for. The probabilities must be between 0 and 1.",
        "schema": {
          "type": "array",
          "items": {
            "type": "number",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "q": {
        "description": "A number of intervals to calculate quantiles for. Calculates q-quantiles with (nearly) equal-sized intervals.",
        "schema": {
          "type": "integer",
          "minimum": 2
        }
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that an array with `null` values is returned if any element is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "An array with the computed quantiles. The list has either\n\n* as many elements as the given list of `probabilities` had or\n* *`q`-1* elements.\n\nIf the input array is empty the resulting array is filled with as many `null` values as required according to the list above. For an example, see the 'Empty array example'.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "exceptions": {
      "QuantilesParameterMissing": {
        "message": "The process 'quantiles' requires either the 'probabilities' or 'q' parameter to be set."
      },
      "QuantilesParameterConflict": {
        "message": "The process 'quantiles' only allows that either the 'probabilities' or the 'q' parameter is set."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            2,
            4,
            4,
            4,
            5,
            5,
            7,
            9
          ],
          "probabilities": [
            0.005,
            0.01,
            0.02,
            0.05,
            0.1,
            0.5
          ]
        },
        "returns": [
          2.07,
          2.14,
          2.28,
          2.7,
          3.4,
          4.5
        ]
      },
      {
        "arguments": {
          "data": [
            2,
            4,
            4,
            4,
            5,
            5,
            7,
            9
          ],
          "q": 4
        },
        "returns": [
          4,
          4.5,
          5.5
        ]
      },
      {
        "arguments": {
          "data": [
            -1,
            -0.5,
            null,
            1
          ],
          "q": 2
        },
        "returns": [
          -0.5
        ]
      },
      {
        "arguments": {
          "data": [
            -1,
            -0.5,
            null,
            1
          ],
          "q": 4,
          "ignore_nodata": false
        },
        "returns": [
          null,
          null,
          null
        ]
      },
      {
        "title": "Empty array example",
        "arguments": {
          "data": [],
          "probabilities": [
            0.1,
            0.5
          ]
        },
        "returns": [
          null,
          null
        ]
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Quantile",
        "title": "Quantiles explained by Wikipedia"
      }
    ]
  },
  {
    "id": "rearrange",
    "summary": "Rearranges an array based on a permutation",
    "description": "Rearranges an array based on a permutation.",
    "categories": [
      "arrays",
      "sorting"
    ],
    "parameter_order": [
      "data",
      "order"
    ],
    "parameters": {
      "data": {
        "description": "An array to rearrange.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        },
        "required": true
      },
      "order": {
        "description": "A permutation used for rearranging, i.e. a ranked list of element positions in the original list. The positions must be zero-based.",
        "schema": {
          "type": "array",
          "items": {
            "type": "integer",
            "minimum": 0
          }
        },
        "required": true
      }
    },
    "returns": {
      "description": "The rearranged array.",
      "schema": {
        "type": "array",
        "items": {
          "description": "Any data type is allowed."
        }
      }
    },
    "examples": [
      {
        "title": "Reverse a list",
        "arguments": {
          "data": [
            5,
            4,
            3
          ],
          "order": [
            2,
            1,
            0
          ]
        },
        "returns": [
          3,
          4,
          5
        ]
      },
      {
        "title": "Remove two elements",
        "arguments": {
          "data": [
            5,
            4,
            3,
            2
          ],
          "order": [
            1,
            3
          ]
        },
        "returns": [
          4,
          2
        ]
      },
      {
        "title": "Swap two elements",
        "arguments": {
          "data": [
            5,
            4,
            3,
            2
          ],
          "order": [
            0,
            2,
            1,
            3
          ]
        },
        "returns": [
          5,
          3,
          4,
          2
        ]
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Permutation.html",
        "title": "Permutation explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "reduce",
    "summary": "Reduce dimensions",
    "description": "Dimensions are specified in the `cube:dimensions` property of the STAC collection, e.g. `temporal` or `x`. Note that spatial dimensions could be x, y or z. Spectral is a separate dimension for MSI. Nominal values are possible and need to be mapped, e.g. band names to wavelengths, date strings to numeric timestamps since 1970 etc.",
    "categories": [
      "cubes",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "reducer",
      "dimension"
    ],
    "parameters": {
      "data": {
        "description": "",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "reducer": {
        "description": "",
        "schema": {
          "type": "object",
          "format": "callback",
          "properties": {
            "data": {
              "description": "An array with elements of any type.",
              "type": "array",
              "items": {
                "description": "Any data type."
              }
            }
          }
        },
        "required": true
      },
      "dimension": {
        "description": "",
        "schema": {
          "type": "string"
        },
        "required": true
      }
    },
    "returns": {
      "description": "A data cube with the newly computed values. The number of dimensions is reduced, but the resolution and cardinality are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "resample_spatial",
    "summary": "Resample spatial dimension",
    "description": "Resamples the spatial dimension.",
    "categories": [
      "cubes",
      "aggregate"
    ],
    "parameter_order": [
      "data",
      "method",
      "target"
    ],
    "parameters": {
      "data": {
        "description": "",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "method": {
        "description": "",
        "schema": {
          "type": "string",
          "default": null
        }
      },
      "target": {
        "description": "",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      }
    },
    "returns": {
      "description": "A data cube with potentially lower spatial resolution and potentially lower cardinality, but the same number of dimensions as the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "resample_temporal",
    "summary": "Resample the temporal dimension",
    "description": "Resamples the temporal dimension. If dimension is not set, the data cube is expected to have only one temporal dimension.",
    "categories": [
      "cubes",
      "aggregate"
    ],
    "parameter_order": [
      "data",
      "method",
      "target",
      "dimension"
    ],
    "parameters": {
      "data": {
        "description": "",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "method": {
        "description": "",
        "schema": {
          "type": "string",
          "default": null
        }
      },
      "target": {
        "description": "",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "dimension": {
        "description": "",
        "schema": {
          "type": "string"
        }
      }
    },
    "returns": {
      "description": "A data cube with potentially lower temporal resolution and potentially lower cardinality, but the same number of dimensions as the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "round",
    "summary": "Rounds to a specified precision",
    "description": "Rounds a real number `x` to specified precision `p`.\n\nIf the fractional part of `x` is halfway between two integers, one of which is even and the other odd, then the even number is returned.\nThis behaviour follows [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935). This kind of rounding is also called \"rounding to nearest\" or \"banker's rounding\". It minimizes rounding errors that result from consistently rounding a midpoint value in a single direction.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > rounding"
    ],
    "parameter_order": [
      "x",
      "p"
    ],
    "parameters": {
      "x": {
        "description": "A number to round.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      },
      "p": {
        "description": "A positive number specifies the number of digits after the decimal point to round to. A negative number means rounding to a power of ten, so for example *-2* rounds to the nearest hundred. Defaults to *0*.",
        "schema": {
          "type": "integer",
          "default": 0
        }
      }
    },
    "returns": {
      "description": "The rounded number.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.56,
          "p": 1
        },
        "returns": 3.6
      },
      {
        "arguments": {
          "x": -0.4444444,
          "p": 2
        },
        "returns": -0.44
      },
      {
        "arguments": {
          "x": -2.5
        },
        "returns": -2
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": -4
      },
      {
        "arguments": {
          "x": 1234.5,
          "p": -2
        },
        "returns": 1200
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/AbsoluteValue.html",
        "title": "Absolute value explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "run_process_graph",
    "summary": "Load and run a stored process graph",
    "description": "Loads and executes a stored process graph.\n\nThe process can either load\n\n* a locally stored process graph by id, which is stored by the authenticated user on the back-end currently connected to or\n* a remotely stored and published process graph by absolute URI, for example from [openEO Hub](https://hub.openeo.org).",
    "categories": [
      "import"
    ],
    "parameter_order": [
      "id",
      "variables"
    ],
    "parameters": {
      "id": {
        "description": "A process graph id or an absolute URI to an externally hosted process graph.",
        "schema": {
          "anyOf": [
            {
              "description": "URI",
              "type": "string",
              "format": "uri"
            },
            {
              "description": "Process graph id",
              "type": "string",
              "pattern": "^[A-Za-z0-9_\\-\\.~]+$"
            }
          ]
        },
        "required": true
      },
      "variables": {
        "description": "An object holding key-value-pairs with values for variables that are defined by the process graph. The key of the pair has to be the corresponding `variable_id` for the value specified. The replacement for the variable is the value of the pair.",
        "schema": {
          "type": "object",
          "default": {}
        }
      }
    },
    "returns": {
      "description": "The result of processing the process graph.",
      "schema": {
        "description": "Any data type."
      }
    }
  },
  {
    "id": "run_udf_remotely",
    "summary": "Run a remotely hosted UDF container",
    "description": "**EXPERIMENTAL.** Runs a remotely hosted UDF container that follows the openEO UDF specification. See ``run_udf()`` for more information on usage and options.",
    "categories": [
      "import",
      "udf"
    ],
    "parameter_order": [
      "url",
      "options"
    ],
    "parameters": {
      "url": {
        "description": "URL to a remote UDF service.",
        "schema": {
          "type": "string",
          "format": "uri"
        },
        "required": true
      },
      "options": {
        "description": "Options that should be passed to the UDF.",
        "schema": {
          "type": "object",
          "default": {}
        }
      }
    },
    "returns": {
      "description": "The data processed by the UDF service.",
      "schema": {
        "description": "Any data type."
      }
    }
  },
  {
    "id": "run_udf",
    "summary": "Run an UDF",
    "description": "**EXPERIMENTAL.** Runs an UDF in one of the supported runtime environments.\n\nThe process can either:\n\n1. load and run a locally stored UDF from a file in the workspace of the authenticated user. The path to the UDF file must be relative to the root directory of the user's workspace, so without the user id in the path.\n2. fetch and run a remotely stored and published UDF by absolute URI, for example from [openEO Hub](https://hub.openeo.org)).\n3. run the source code specified inline as string.\n\nThe loaded UDF can be executed as callback in several processes such as ``aggregate_temporal()``, ``apply()``, ``apply_dimension()``, ``filter()`` and ``reduce()``.",
    "categories": [
      "import",
      "udf"
    ],
    "parameter_order": [
      "udf",
      "runtime",
      "options"
    ],
    "parameters": {
      "udf": {
        "description": "Either source code, an absolute URL or a path to an UDF script.",
        "schema": {
          "anyOf": [
            {
              "description": "URI to an UDF",
              "type": "string",
              "format": "uri"
            },
            {
              "description": "Source code as string",
              "type": "string"
            }
          ]
        },
        "required": true
      },
      "runtime": {
        "description": "An UDF runtime identifier available at the back-end.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "options": {
        "description": "Options that should be passed to the UDF.",
        "schema": {
          "type": "object",
          "default": {}
        }
      }
    },
    "returns": {
      "description": "The data processed by the UDF.",
      "schema": {
        "description": "Any data type."
      }
    }
  },
  {
    "id": "save_result",
    "summary": "Save processed data to storage",
    "description": "Saves processed data to the data storage. This process aims to be compatible to GDAL/OGR formats and options. STAC-compatible metadata should be stored with the processed data.\n\nCalling this process may be rejected by back-ends in the context of secondary web services.",
    "categories": [
      "cubes",
      "export"
    ],
    "parameter_order": [
      "data",
      "format",
      "options"
    ],
    "parameters": {
      "data": {
        "description": "The data to save.",
        "schema": {
          "anyOf": [
            {
              "type": "object",
              "format": "raster-cube"
            },
            {
              "type": "object",
              "format": "vector-cube"
            }
          ]
        },
        "required": true
      },
      "format": {
        "description": "The file format to save to. It must be one of the values that the server reports as supported output formats, which usually correspond to the short GDAL/OGR codes. This parameter is *case insensitive*.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "options": {
        "description": "The file format options to be used to create the file(s). Must correspond to the options that the server reports as supported options for the chosen `format`. The option names and valid values usually correspond to the GDAL/OGR format options.",
        "schema": {
          "type": "object",
          "default": {}
        }
      }
    },
    "returns": {
      "description": "`false` if saving failed, `true` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://www.gdal.org/formats_list.html",
        "title": "GDAL Raster Formats"
      },
      {
        "rel": "about",
        "href": "https://www.gdal.org/ogr_formats.html",
        "title": "OGR Vector Formats"
      }
    ]
  },
  {
    "id": "sd",
    "summary": "Standard deviation",
    "description": "Computes the sample standard deviation, which quantifies the amount of variation of an array of numbers. It is defined to be the square root of the corresponding variance (see ``variance()``).\n\nA low standard deviation indicates that the values tend to be close to the expected value, while a high standard deviation indicates that the values are spread out over a wider range.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed sample standard deviation.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            -1,
            1,
            3,
            null
          ]
        },
        "returns": 2
      },
      {
        "arguments": {
          "data": [
            -1,
            1,
            3,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/StandardDeviation.html",
        "title": "Standard deviation explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "sgn",
    "summary": "Signum",
    "description": "The signum (also known as *sign*) of `x` is defined as:\n\n* *1* if *x > 0*\n* *0* if *x = 0*\n* *-1* if *x < 0*\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed signum value of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": -2
        },
        "returns": -1
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": null
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Sign.html",
        "title": "Sign explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "sin",
    "summary": "Sine",
    "description": "Computes the sine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed sine of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Sine.html",
        "title": "Sine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "sinh",
    "summary": "Hyperbolic sine",
    "description": "Computes the hyperbolic sine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed hyperbolic sine of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/HyperbolicSine.html",
        "title": "Hyperbolic sine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "sort",
    "summary": "Sort data",
    "description": "Sorts an array into ascending (default) or descending order.\n\nThis process is an alias to call ``order()`` and ``rearrange()`` consecutively: `rearrange(data, order(data, nodata))`. This process could be faster though. See ``order()`` for more information on sorting behaviour.",
    "categories": [
      "arrays",
      "sorting"
    ],
    "parameter_order": [
      "data",
      "asc",
      "nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array with data to sort.",
        "schema": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "string",
                "format": "date"
              },
              {
                "type": "string",
                "format": "time"
              }
            ]
          }
        },
        "required": true
      },
      "asc": {
        "description": "The default sort order is ascending, with smallest values first. To sort in reverse (descending) order, set this parameter to `false`.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      },
      "nodata": {
        "description": "Controls the handling of no-data values (`null`). By default they are removed. If `true`, missing values in the data are put last; if `false`, they are put first.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ],
          "default": null
        }
      }
    },
    "returns": {
      "description": "The sorted array.",
      "schema": {
        "type": "array",
        "items": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ]
        },
        "returns": [
          -1,
          2,
          3,
          4,
          6,
          7,
          8,
          9,
          9
        ]
      },
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ],
          "asc": false,
          "nodata": true
        },
        "returns": [
          9,
          9,
          8,
          7,
          6,
          4,
          3,
          2,
          -1,
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "sqrt",
    "summary": "Square root",
    "description": "Computes the square root of a real number `x`. This process is an alias for `x` to the power of *0.5*: `power(x, 0.5)`.\n\nA square root of x is a number a such that *a^2^ = x*. Therefore, the square root is the inverse function of a to the power of 2, but only for *a >= 0*.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math",
      "math > exponential & logarithmic"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed square root.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 1
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 9
        },
        "returns": 3
      },
      {
        "arguments": {
          "x": null
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/SquareRoot.html",
        "title": "Square root explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "subtract",
    "summary": "Subtraction of a sequence of numbers",
    "description": "Takes the first element of a sequential array of numbers and subtracts all other elements from it.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) whenever the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nBy default no-data values are ignored. Setting `ignore_nodata` to `false` considers no-data values so that `null` is returned if any element is such a value.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers with at least two elements.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          },
          "minItems": 2
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed result of the sequence of numbers.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "exceptions": {
      "SubtrahendMissing": {
        "message": "Subtraction requires at least two numbers (a minuend and one or more subtrahends)."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            5,
            10
          ]
        },
        "returns": -5
      },
      {
        "arguments": {
          "data": [
            -2,
            4,
            -2
          ]
        },
        "returns": -4
      },
      {
        "arguments": {
          "data": [
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Subtraction.html",
        "title": "Subtraction explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "sum",
    "summary": "Addition of a sequence of numbers",
    "description": "Sums up all elements in a sequential array of numbers and returns the computed sum.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) whenever the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nBy default no-data values are ignored. Setting `ignore_nodata` to `false` considers no-data values so that `null` is returned if any element is such a value.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers with at least two elements.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          },
          "minItems": 2
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed sum of the sequence of numbers.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "exceptions": {
      "SummandMissing": {
        "message": "Addition requires at least two numbers."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            5,
            1
          ]
        },
        "returns": 6
      },
      {
        "arguments": {
          "data": [
            -2,
            4,
            2.5
          ]
        },
        "returns": 4.5
      },
      {
        "arguments": {
          "data": [
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Sum.html",
        "title": "Sum explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "tan",
    "summary": "Tangent",
    "description": "Computes the tangent of `x`. The tangent is defined to be the sine of x divided by the cosine of x.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed tangent of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Tangent.html",
        "title": "Tangent explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "tanh",
    "summary": "Hyperbolic tangent",
    "description": "Computes the hyperbolic tangent of `x`. The tangent is defined to be the hyperbolic sine of x divided by the hyperbolic cosine of x.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed hyperbolic tangent of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/HyperbolicTangent.html",
        "title": "Hyperbolic tangent explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "text_begins",
    "summary": "Text begins with another text",
    "description": "Checks whether the text (also known as *string*) specified for `data` contains the text specified for `pattern` at the very beginning. Both are expected to be encoded in UTF-8 by default. Regular expressions are not supported.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameter_order": [
      "data",
      "pattern",
      "case_sensitive"
    ],
    "parameters": {
      "data": {
        "description": "Text in which to find something at the beginning.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "pattern": {
        "description": "Text to find at the beginning of `data`.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "case_sensitive": {
        "description": "Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "`true` if `data` begins with `pattern`, false` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "amet"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "Lorem"
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "lorem"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "lorem",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "",
          "pattern": "",
          "case_sensitive": false
        },
        "returns": true
      }
    ]
  },
  {
    "id": "text_contains",
    "summary": "Text contains another text",
    "description": "Checks whether the text (also known as *string*) specified for `data` contains the text specified for `pattern`. Both are expected to be encoded in UTF-8 by default. Regular expressions are not supported.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameter_order": [
      "data",
      "pattern",
      "case_sensitive"
    ],
    "parameters": {
      "data": {
        "description": "Text in which to find something in.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "pattern": {
        "description": "Text to find in `data`.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "case_sensitive": {
        "description": "Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "`true` if `data` contains the `pattern`, false` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "openEO"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "ipsum dolor"
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "Ipsum Dolor"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "SIT",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "",
          "pattern": "",
          "case_sensitive": false
        },
        "returns": true
      }
    ]
  },
  {
    "id": "text_ends",
    "summary": "Text ends with another text",
    "description": "Checks whether the text (also known as *string*) specified for `data` contains the text specified for `pattern` at the very end. Both are expected to be encoded in UTF-8 by default. Regular expressions are not supported.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameter_order": [
      "data",
      "pattern",
      "case_sensitive"
    ],
    "parameters": {
      "data": {
        "description": "Text in which to find something at the end.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "pattern": {
        "description": "Text to find at the end of `data`.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "case_sensitive": {
        "description": "Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "`true` if `data` ends with `pattern`, false` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "amet"
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "AMET"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "Lorem"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "AMET",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "",
          "pattern": "",
          "case_sensitive": false
        },
        "returns": true
      }
    ]
  },
  {
    "id": "trim",
    "summary": "Remove slices with no-data values",
    "description": "Removes slices solely containing no-data values. If the dimension is irregular categorical then slices in the middle can be removed.",
    "categories": [
      "cubes"
    ],
    "parameters": {
      "data": {
        "description": "A raster data cube to trim.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      }
    },
    "returns": {
      "description": "A trimmed raster data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "variance",
    "summary": "Variance",
    "description": "Computes the sample variance of an array of numbers by calculating the square of the standard deviation (see ``sd()``). It is defined to be the expectation of the squared deviation of a random variable from its expected value. Basically, it measures how far the numbers in the array are spread out from their average value.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed sample variance.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            -1,
            1,
            3
          ]
        },
        "returns": 4
      },
      {
        "arguments": {
          "data": [
            2,
            3,
            3,
            null,
            4,
            4,
            5
          ]
        },
        "returns": 1.1
      },
      {
        "arguments": {
          "data": [
            -1,
            1,
            null,
            3
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Variance.html",
        "title": "Variance explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "xor",
    "summary": "Is exactly one value true?",
    "description": "Checks if **exactly one** of the values is true. Evaluates each expression from the first to the last element and stops once the outcome is unambiguous.\n\nIf only one value is given the process evaluates to the given value. If no value is given (i.e. the array is empty) the process returns `null`.\n\nBy default all no-data values are ignored so that the process returns `true` if exactly one of the other values is true and otherwise returns `false`.\nSetting the `ignore_nodata` flag to `false` considers no-data values so that `null` is a valid logical object. If a component is `null`, the result will be `null` if the outcome is ambiguous. See the following truth table:\n\n```\n      || null | false | true\n----- || ---- | ----- | -----\nnull  || null | null  | null\nfalse || null | false | true\ntrue  || null | true  | false\n```",
    "categories": [
      "logic",
      "reducer"
    ],
    "parameter_order": [
      "expressions",
      "ignore_nodata"
    ],
    "parameters": {
      "expressions": {
        "description": "A set of boolean values.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "boolean",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not and ignores them by default.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "Boolean result of the logical expressions.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "expressions": [
            false,
            null
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true,
            null
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            false,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "expressions": [
            true,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "expressions": [
            true,
            false,
            true,
            false
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true,
            false
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            false,
            false
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": []
        },
        "returns": null
      }
    ]
  }
]