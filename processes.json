[
  {
    "id": "absolute",
    "summary": "Absolute value",
    "description": "Computes the absolute value of a real number `x`, which is the \"unsigned\" portion of x and often denoted as *|x|*.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed absolute value.",
      "schema": {
        "type": [
          "number",
          "null"
        ],
        "minimum": 0
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 3.5
      },
      {
        "arguments": {
          "x": -0.4
        },
        "returns": 0.4
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": 3.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/AbsoluteValue.html",
        "title": "Absolute value explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "add_dimension",
    "summary": "Add a new dimension",
    "description": "Adds a new named dimension to the data cube.\n\nAfterwards, the dimension can be referenced with the specified `name`. If a dimension with the specified name exists, the process fails with a `DimensionExists` error. The dimension value of the dimension is set to the specified `value`.",
    "categories": [
      "cubes"
    ],
    "parameter_order": [
      "data",
      "name",
      "value",
      "type"
    ],
    "parameters": {
      "data": {
        "description": "A data cube to add the dimension to.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "name": {
        "description": "Name for the dimension.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "value": {
        "description": "A dimension value (**not** a pixel value).",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "string"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "type": {
        "description": "The type of dimension, defaults to `other`.",
        "schema": {
          "type": "string",
          "enum": [
            "spatial",
            "temporal",
            "bands",
            "other"
          ],
          "default": "other"
        }
      }
    },
    "returns": {
      "description": "The data cube with a newly added dimension.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "exceptions": {
      "DimensionExists": {
        "message": "A dimension with the specified name already exists."
      }
    }
  },
  {
    "id": "aggregate_polygon",
    "summary": "Compute zonal statistics for polygons",
    "description": "Aggregates zonal statistics for one or multiple polygons over the spatial dimensions.\n\nThe process considers all pixels for which the point at the pixel center intersects with the corresponding polygon (as defined in the Simple Features standard by the OGC).\n\nThe data cube must have been reduced to only contain two raster dimensions and a third dimension the values are aggregated for, for example the temporal dimension to get a time series. Otherwise this process fails with the `TooManyDimensions` error.\n\nThe number of total and valid pixels is returned together with the calculated values.",
    "categories": [
      "cubes",
      "aggregate & resample"
    ],
    "experimental": true,
    "parameter_order": [
      "data",
      "polygons",
      "reducer",
      "name",
      "binary"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "polygons": {
        "description": "One or more polygons to calculate zonal statistics for. Either specified as GeoJSON or vector data cube.\n\nFor GeoJSON this can be one of the following GeoJSON types:\n\n* A `Polygon` geometry,\n* a `GeometryCollection` containing Polygons,\n* a `Feature` with a `Polygon` geometry or\n* a `FeatureCollection` containing `Feature`s with a `Polygon` geometry.",
        "schema": {
          "anyOf": [
            {
              "type": "object",
              "format": "geojson"
            },
            {
              "type": "object",
              "format": "vector-cube"
            }
          ]
        },
        "required": true
      },
      "reducer": {
        "description": "A reducer to be applied on all values of each geometry. The reducer must be a callable process (or a set of processes as process graph) such as ``mean()`` that accepts by default array as input. The process can also work on two values by setting the parameter `binary` to `true`.",
        "schema": {
          "anyOf": [
            {
              "title": "Unary behaviour",
              "description": "Passes an array to the reducer.",
              "type": "object",
              "format": "callback",
              "parameters": {
                "data": {
                  "description": "An array with elements of any data type.",
                  "type": "array",
                  "items": {
                    "description": "Any data type."
                  }
                }
              }
            },
            {
              "title": "Binary behaviour",
              "description": "Passes two values to the reducer.",
              "type": "object",
              "format": "callback",
              "parameters": {
                "x": {
                  "description": "The first value. Any data type could be passed."
                },
                "y": {
                  "description": "The second value. Any data type could be passed."
                }
              }
            }
          ]
        },
        "required": true
      },
      "name": {
        "description": "The property name (for GeoJSON) or the new dimension name (for vector cubes) to be used for storing the results. Defaults to `result`.",
        "schema": {
          "type": "string",
          "default": "result"
        }
      },
      "binary": {
        "description": "Specifies whether the process should pass two values to the reducer or a list of values (default).\n\nIf the process passes two values, the reducer must be both associative and commutative as the execution may be executed in parallel and therefore the order of execution is arbitrary.\n\nThis parameter is especially useful for UDFs passed as reducers. Back-ends may still optimize and parallelize processes that work on list of values.",
        "schema": {
          "type": "boolean",
          "default": false
        }
      }
    },
    "returns": {
      "description": "A vector data cube or a GeoJSON object, depending on the input of the `polygons` parameter.\n\nThe computed value is stored in a property (GeoJSON) or dimension (vector cube) with the name that was specified in the parameter `name`.\n\nThe computation also stores information about the total count of pixels (valid + invalid pixels) and the number of valid pixels (see ``is_valid()``) in each geometry. In GeoJSON these are stored as properties with the names `{name}_total_count` and `{name}_valid_count` (replace `{name}` with the value of the `name` parameter). In a vector data cube, these values are stored as attributes of the result value with the attribute names `total_count` and `valid_count`.\n\nIf the input was GeoJSON and the therefore the return value is also a GeoJSON object, the geometries (`Polygon` or `GeometryCollection`) get wrapped in a `Feature` or `FeatureCollection` respectively. The results of the computations are stored in the `properties` of each GeoJSON `Feature`.",
      "schema": {
        "anyOf": [
          {
            "type": "object",
            "format": "geojson"
          },
          {
            "type": "object",
            "format": "vector-cube"
          }
        ]
      }
    },
    "exceptions": {
      "TooManyDimensions": {
        "message": "The number of dimensions must be reduced to three for 'aggregate_polygon'."
      }
    },
    "links": [
      {
        "href": "https://github.com/Open-EO/openeo-processes/issues/2",
        "rel": "experimental",
        "title": "More information about the experimental status of the process"
      },
      {
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/glossary/#aggregation-and-resampling",
        "rel": "about",
        "title": "Aggregation explained in the openEO glossary"
      },
      {
        "href": "http://www.opengeospatial.org/standards/sfa",
        "rel": "about",
        "title": "Simple Features standard by the OGC"
      },
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Reduction_Operator",
        "title": "Background information on reduction operators (binary reducers) by Wikipedia"
      }
    ]
  },
  {
    "id": "aggregate_temporal",
    "summary": "Temporal aggregations",
    "description": "Computes a temporal aggregation based on an array of date and/or time intervals.\n\nCalendar hierarchies such as year, month, week etc. must be transformed into specific intervals by the clients. For each interval, all data along the dimension will be passed through the reducer. The computed values will be projected to the labels, so the number of labels and the number of intervals need to be equal.\n\nIf the dimension is not set or is set to `null`, the data cube is expected to only have one temporal dimension.",
    "categories": [
      "cubes",
      "aggregate & resample"
    ],
    "experimental": true,
    "parameter_order": [
      "data",
      "intervals",
      "labels",
      "reducer",
      "dimension",
      "binary"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "intervals": {
        "description": "Left-closed temporal intervals, which are allowed to overlap. Each temporal interval in the array has exactly two elements:\n\n1. The first element is the start of the date and/or time interval. The specified instance in time is **included** in the interval.\n2. The second element is the end of the date and/or time interval. The specified instance in time is **excluded** from the interval.\n\nThe specified temporal strings follow [RFC 3339](https://tools.ietf.org/html/rfc3339). Although [RFC 3339 prohibits the hour to be '24'](https://tools.ietf.org/html/rfc3339#section-5.7), **this process allows the value '24' for the hour** of an end time in order to make it possible that left-closed time intervals can fully cover the day.",
        "schema": {
          "type": "array",
          "format": "temporal-intervals",
          "items": {
            "type": "array",
            "format": "temporal-interval",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "string",
                  "format": "date"
                },
                {
                  "type": "string",
                  "format": "time"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "examples": [
            [
              [
                "2015-01-01",
                "2016-01-01"
              ],
              [
                "2016-01-01",
                "2017-01-01"
              ],
              [
                "2017-01-01",
                "2018-01-01"
              ]
            ],
            [
              [
                "00:00:00Z",
                "12:00:00Z"
              ],
              [
                "12:00:00Z",
                "24:00:00Z"
              ]
            ]
          ]
        },
        "required": true
      },
      "labels": {
        "description": "Labels for the intervals, which can contain dates and/or times. The number of labels and the number of groups need to be equal.",
        "schema": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "string",
                "format": "date"
              },
              {
                "type": "string",
                "format": "time"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "required": true
      },
      "reducer": {
        "description": "A reducer to be applied on all values along the specified dimension. The reducer must be a callable process (or a set of processes as process graph) such as ``mean()`` that accepts by default array as input. The process can also work on two values by setting the parameter `binary` to `true`.",
        "schema": {
          "anyOf": [
            {
              "title": "Unary behaviour",
              "description": "Passes an array to the reducer.",
              "type": "object",
              "format": "callback",
              "parameters": {
                "data": {
                  "description": "An array with elements of any data type.",
                  "type": "array",
                  "items": {
                    "description": "Any data type."
                  }
                }
              }
            },
            {
              "title": "Binary behaviour",
              "description": "Passes two values to the reducer.",
              "type": "object",
              "format": "callback",
              "parameters": {
                "x": {
                  "description": "The first value. Any data type could be passed."
                },
                "y": {
                  "description": "The second value. Any data type could be passed."
                }
              }
            }
          ]
        },
        "required": true
      },
      "dimension": {
        "description": "The temporal dimension for aggregation. All data along the dimension will be passed through the specified reducer. If the dimension is not set or set to `null`, the data cube is expected to only have one temporal dimension. Fails with a `TooManyDimensions` error if it has more dimensions. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Note:** The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.",
        "schema": {
          "type": [
            "string",
            "null"
          ],
          "default": null
        }
      },
      "binary": {
        "description": "Specifies whether the process should pass two values to the reducer or a list of values (default).\n\nIf the process passes two values, the reducer must be both associative and commutative as the execution may be executed in parallel and therefore the order of execution is arbitrary.\n\nThis parameter is especially useful for UDFs passed as reducers. Back-ends may still optimize and parallelize processes that work on list of values.",
        "schema": {
          "type": "boolean",
          "default": false
        }
      }
    },
    "returns": {
      "description": "A data cube with potentially lower resolution and potentially lower cardinality, but the same number of dimensions as the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "examples": [
      {
        "process_graph": {
          "loadco1": {
            "process_id": "load_collection",
            "arguments": {
              "id": "S2B",
              "spatial_extent": null,
              "temporal_extent": null
            }
          },
          "aggreg1": {
            "process_id": "aggregate_temporal",
            "arguments": {
              "data": {
                "from_node": "loadco1"
              },
              "intervals": [
                [
                  "2015-01-01",
                  "2016-01-01"
                ],
                [
                  "2016-01-01",
                  "2017-01-01"
                ],
                [
                  "2017-01-01",
                  "2018-01-01"
                ],
                [
                  "2018-01-01",
                  "2019-01-01"
                ]
              ],
              "labels": [
                [
                  "2015-01-01"
                ],
                [
                  "2016-01-01"
                ],
                [
                  "2017-01-01"
                ],
                [
                  "2018-01-01"
                ]
              ],
              "reducer": {
                "callback": {
                  "median1": {
                    "process_id": "median",
                    "arguments": {
                      "data": {
                        "from_argument": "data"
                      }
                    },
                    "result": true
                  }
                }
              }
            },
            "result": true
          }
        }
      }
    ],
    "exceptions": {
      "TooManyDimensions": {
        "message": "The number of dimensions must be reduced to three for 'aggregate_polygon'."
      },
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      },
      {
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/glossary/#aggregation-and-resampling",
        "rel": "about",
        "title": "Aggregation explained in the openEO glossary"
      },
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Reduction_Operator",
        "title": "Background information on reduction operators (binary reducers) by Wikipedia"
      }
    ]
  },
  {
    "id": "and",
    "summary": "Are all of the values true?",
    "description": "Checks if **all** of the values are true. Evaluates each expression from the first to the last element and stops once the outcome is unambiguous.\n\nIf only one value is given the process evaluates to the given value. If no value is given (i.e. the array is empty) the process returns `null`.\n\nBy default all no-data values are ignored so that the process returns `true` if all other values are true and otherwise returns `false`.\nSetting the `ignore_nodata` flag to `false` considers no-data values so that `null` is a valid logical object. If a component is `null`, the result will be `null` if the outcome is ambiguous. See the following truth table:\n\n```\n      || null  | false | true\n----- || ----- | ----- | -----\nnull  || null  | false | null\nfalse || false | false | false\ntrue  || null  | false | true\n```",
    "categories": [
      "logic",
      "reducer"
    ],
    "parameter_order": [
      "expressions",
      "ignore_nodata"
    ],
    "parameters": {
      "expressions": {
        "description": "A set of boolean values.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "boolean",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not and ignores them by default.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "Boolean result of the logical expressions.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "expressions": [
            false,
            null
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true,
            null
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            false,
            null
          ],
          "ignore_nodata": false
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "expressions": [
            true,
            false,
            true,
            false
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true,
            false
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true,
            true
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            true
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": []
        },
        "returns": null
      }
    ]
  },
  {
    "id": "apply_dimension",
    "summary": "Applies an n-ary process to all pixels",
    "description": "Applies an **n-ary** process (i.e. takes an array of pixel values instead of a single pixel value) to a raster data cube. In contrast, the process ``apply()`` applies an unary process to all pixel values.\n\nBy default, `apply_dimension` applies the process on all pixel values in the data cube as ``apply()`` does, but the parameter `dimension` can be specified to work only on a particular dimension only. For example, if the temporal dimension is specified the process will work on a time series of pixel values.\n\nThe n-ary process must return as many elements in the returned array as there are in the input array. Otherwise a `CardinalityChanged` error must be returned.",
    "categories": [
      "cubes"
    ],
    "parameter_order": [
      "data",
      "process",
      "dimension"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "process": {
        "description": "A process (callback) to be applied on each dimension. The specified process needs to accept an array as parameter and must return as many elements in the returned array as there are in the input array.",
        "schema": {
          "type": "object",
          "format": "callback",
          "parameters": {
            "data": {
              "description": "An array with elements of any data type.",
              "type": "array",
              "items": {
                "description": "Any data type."
              }
            }
          }
        },
        "required": true
      },
      "dimension": {
        "description": "The name of the dimension to apply the process on. By default, applies the process on all pixel values (as ``apply()`` does).",
        "schema": {
          "type": [
            "string",
            "null"
          ],
          "default": null
        }
      }
    },
    "returns": {
      "description": "A data cube with the newly computed values for the specified . The resolution, cardinality and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "exceptions": {
      "CardinalityChanged": {
        "message": "The callback returned less or more elements than it received."
      },
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      }
    }
  },
  {
    "id": "apply_kernel",
    "summary": "Applies a kernel to compute pixel-wise values",
    "description": "Applies a focal operation based on a weighted kernel to each value of the specified dimensions in the data cube.",
    "categories": [
      "cubes",
      "math > image filter"
    ],
    "parameter_order": [
      "data",
      "kernel",
      "factor"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "kernel": {
        "description": "The kernel to be applied on the data cube. The kernel has to be as many dimensions as the data cube has dimensions.",
        "schema": {
          "type": "array",
          "format": "kernel",
          "items": {
            "description": "Usually a multi-dimensional array of numbers."
          }
        },
        "required": true
      },
      "factor": {
        "description": "A factor that is multiplied to each value computed by the focal operation.\n\nThis is basically a shortcut for explicitly multiplying each value by a factor afterwards, which is often required for some kernel-based algorithms such as the Gaussian blur.",
        "schema": {
          "type": "number",
          "default": 1
        }
      }
    },
    "returns": {
      "description": "A data cube with the newly computed values. The resolution, cardinality and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "apply",
    "summary": "Applies a unary process to each pixel",
    "description": "Applies a **unary** process which takes a single value such as `abs` or `sqrt` to each pixel value in the data cube (i.e. a local operation). In contrast, the process ``apply_dimension()`` applies an n-ary process to a particular dimension.",
    "categories": [
      "cubes"
    ],
    "parameter_order": [
      "data",
      "process"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "process": {
        "description": "A process (callback) to be applied on each value. The specified process must be unary meaning that it must work on a single value.",
        "schema": {
          "type": "object",
          "format": "callback",
          "parameters": {
            "x": {
              "description": "A value of any type could be passed."
            }
          }
        },
        "required": true
      }
    },
    "returns": {
      "description": "A data cube with the newly computed values. The resolution, cardinality and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "arccos",
    "summary": "Inverse cosine",
    "description": "Computes the arc cosine of `x`. The arc cosine is the inverse function of the cosine so that *arccos(cos(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1
        },
        "returns": 0
      },
      {
        "process_graph": {
          "cos1": {
            "process_id": "cos",
            "arguments": {
              "x": 0.5
            }
          },
          "arccos1": {
            "process_id": "arccos",
            "arguments": {
              "x": {
                "from_node": "cos1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseCosine.html",
        "title": "Inverse cosine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "arcosh",
    "summary": "Inverse hyperbolic cosine",
    "description": "Computes the inverse hyperbolic cosine of `x`. It is the inverse function of the hyperbolic cosine so that *arcosh(cosh(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1
        },
        "returns": 0
      },
      {
        "process_graph": {
          "cosh1": {
            "process_id": "cosh",
            "arguments": {
              "x": 0.5
            }
          },
          "arccosh1": {
            "process_id": "arcosh",
            "arguments": {
              "x": {
                "from_node": "cosh1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseHyperbolicCosine.html",
        "title": "Inverse hyperbolic cosine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "arcsin",
    "summary": "Inverse sine",
    "description": "Computes the arc sine of `x`. The arc sine is the inverse function of the sine so that *arcsin(sin(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "process_graph": {
          "sin1": {
            "process_id": "sin",
            "arguments": {
              "x": 0.5
            }
          },
          "arcsin1": {
            "process_id": "arcsin",
            "arguments": {
              "x": {
                "from_node": "sin1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseSine.html",
        "title": "Inverse sine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "arctan",
    "summary": "Inverse tangent",
    "description": "Computes the arc tangent of `x`. The arc tangent is the inverse function of the tangent so that *arctan(tan(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "process_graph": {
          "tan1": {
            "process_id": "tan",
            "arguments": {
              "x": 0.5
            }
          },
          "arctan1": {
            "process_id": "arctan",
            "arguments": {
              "x": {
                "from_node": "tan1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseTangent.html",
        "title": "Inverse tangent explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "arctan2",
    "summary": "Inverse tangent of two numbers.",
    "description": "Computes the arc tangent of two numbers `x` and `y`. It is similar to calculating the arc tangent of *y / x*, except that the signs of both arguments are used to determine the quadrant of the result.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated if any of the arguments is `null`.",
    "categories": [
      "math > trigonometric"
    ],
    "parameter_order": [
      "y",
      "x"
    ],
    "parameters": {
      "y": {
        "description": "A number to be used as dividend.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      },
      "x": {
        "description": "A number to be used as divisor.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "y": 0,
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "y": null,
          "x": 1.5
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Atan2",
        "title": "Two-argument inverse tangent explained by Wikipedia"
      }
    ]
  },
  {
    "id": "array_contains",
    "summary": "List contains an element",
    "description": "Checks whether the list (also known as *array*) specified for `data` contains the value specified in `element`.\n\n**Remarks:**\n\n* Data types MUST be checked strictly, for example a string with the content *1* is not equal to the number *1*.\n* An integer *1* is equal to a floating point number *1.0* as `integer` is a sub-type of `number`. Still, this process may return unexpectedly `false` when comparing floating point numbers due to floating point inaccuracy in machine-based computation.\n* Temporal strings are treated as normal strings and MUST NOT be interpreted.",
    "categories": [
      "arrays",
      "comparison"
    ],
    "parameter_order": [
      "data",
      "element"
    ],
    "parameters": {
      "data": {
        "description": "List in which to find a value in.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        },
        "required": true
      },
      "element": {
        "description": "Value to find in `data`.",
        "schema": {
          "description": "Any data type is allowed."
        },
        "required": true
      }
    },
    "returns": {
      "description": "Returns `true` if the list contains the value, false` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            2,
            3
          ],
          "element": 2
        },
        "returns": true
      },
      {
        "arguments": {
          "data": [
            "A",
            "B",
            "C"
          ],
          "element": "b"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3
          ],
          "element": "2"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3
          ],
          "element": 2
        },
        "returns": true
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            null
          ],
          "element": null
        },
        "returns": true
      },
      {
        "arguments": {
          "data": [
            [
              1,
              2
            ],
            [
              3,
              4
            ]
          ],
          "element": [
            1,
            2
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "data": [
            [
              1,
              2
            ],
            [
              3,
              4
            ]
          ],
          "element": 2
        },
        "returns": false
      },
      {
        "arguments": {
          "data": [
            {
              "a": "b"
            },
            {
              "c": "d"
            }
          ],
          "element": {
            "a": "b"
          }
        },
        "returns": true
      }
    ]
  },
  {
    "id": "array_element",
    "summary": "Get an element from an array",
    "description": "Returns the element at the specified index from the array.",
    "categories": [
      "arrays"
    ],
    "parameter_order": [
      "data",
      "index",
      "return_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        },
        "required": true
      },
      "index": {
        "description": "The zero-based index of the element to retrieve.",
        "schema": {
          "type": "integer"
        },
        "required": true
      },
      "return_nodata": {
        "description": "By default this process throws an `IndexOutOfBounds` exception if the index is invalid. If you want to return `null` instead, set this flag to `true`.",
        "schema": {
          "type": "boolean",
          "default": false
        }
      }
    },
    "returns": {
      "description": "The value of the requested element.",
      "schema": {
        "description": "Any data type is allowed."
      }
    },
    "exceptions": {
      "IndexOutOfBounds": {
        "message": "The array has no element with the specified index."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            9,
            8,
            7,
            6,
            5
          ],
          "index": 2
        },
        "returns": 7
      },
      {
        "arguments": {
          "data": [
            "A",
            "B",
            "C"
          ],
          "index": 0
        },
        "returns": "A"
      },
      {
        "arguments": {
          "data": [],
          "index": 0,
          "return_nodata": true
        },
        "returns": null
      }
    ]
  },
  {
    "id": "arsinh",
    "summary": "Inverse hyperbolic sine",
    "description": "Computes the inverse hyperbolic sine of `x`. It is the inverse function of the hyperbolic sine so that *arsinh(sinh(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "process_graph": {
          "sinh1": {
            "process_id": "sinh",
            "arguments": {
              "x": 0.5
            }
          },
          "arcsinh1": {
            "process_id": "arsinh",
            "arguments": {
              "x": {
                "from_node": "sinh1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseHyperbolicSine.html",
        "title": "Inverse hyperbolic sine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "artanh",
    "summary": "Inverse hyperbolic tangent",
    "description": "Computes the inverse hyperbolic tangent of `x`. It is the inverse function of the hyperbolic tangent so that *artanh(tanh(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "process_graph": {
          "cosh1": {
            "process_id": "tanh",
            "arguments": {
              "x": 0.5
            }
          },
          "arctanh1": {
            "process_id": "artanh",
            "arguments": {
              "x": {
                "from_node": "tanh1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseHyperbolicTangent.html",
        "title": "Inverse hyperbolic tangent explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "between",
    "summary": "Between comparison",
    "description": "By default this process checks whether `x` is greater than or equal to `min` and lower than or equal to `max`. Therefore, this process is an alias for `and([gte(x, min), lte(x, max)])` and all definitions from these processes apply here as well.\n\nIf `exclude_max` is set to `true` the upper bound is excluded so that the process checks whether `x` is greater than or equal to `min` and lower than `max`. In this case the process works the same as executing `and([gte(x, min), lt(x, max)])`.\n\nLower and upper bounds are not allowed to be swapped. So `min` MUST be lower than or equal to `max` or otherwise the process always returns `false`.",
    "categories": [
      "comparison"
    ],
    "parameter_order": [
      "x",
      "min",
      "max",
      "exclude_max"
    ],
    "parameters": {
      "x": {
        "description": "",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "min": {
        "description": "Lower boundary (inclusive) to check against.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "max": {
        "description": "Upper boundary (inclusive) to check against.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "exclude_max": {
        "description": "Exclude the upper boundary `max` if set to `true`. Defaults to `false`.",
        "schema": {
          "type": "boolean",
          "default": false
        }
      }
    },
    "returns": {
      "description": "`true` if `x` is between the specified bounds, otherwise `false`.",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "x": null,
          "min": 0,
          "max": 1
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 1,
          "min": 0,
          "max": 1
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 1,
          "min": 0,
          "max": 1,
          "exclude_max": true
        },
        "returns": false
      },
      {
        "description": "Swapped bounds (min is greater than max) MUST always return `false`.",
        "arguments": {
          "x": 0.5,
          "min": 1,
          "max": 0
        },
        "returns": false
      },
      {
        "arguments": {
          "x": -0.5,
          "min": -1,
          "max": 0
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "00:59:59Z",
          "min": "01:00:00+01:00",
          "max": "01:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2018-07-23T17:22:45Z",
          "min": "2018-01-01T00:00:00Z",
          "max": "2018-12-31T23:59:59Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2000-01-01",
          "min": "2018-01-01",
          "max": "2020-01-01"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "2018-12-31T17:22:45Z",
          "min": "2018-01-01",
          "max": "2018-12-31"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2018-12-31T17:22:45Z",
          "min": "2018-01-01",
          "max": "2018-12-31",
          "exclude_max": true
        },
        "returns": false
      }
    ]
  },
  {
    "id": "ceil",
    "summary": "Round fractions up",
    "description": "The least integer greater than or equal to the number `x`.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > rounding"
    ],
    "parameters": {
      "x": {
        "description": "A number to round up.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The number rounded up.",
      "schema": {
        "type": [
          "integer",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 4
      },
      {
        "arguments": {
          "x": -0.4
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": -3
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/CeilingFunction.html",
        "title": "Ceiling explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "clip",
    "summary": "Clips values between minimum and maximum values.",
    "description": "Clips an array of numbers between specified minimum and maximum values. All values larger than the maximal value will have the maximal value, all values lower than minimal value will have the minimal value.",
    "categories": [
      "math"
    ],
    "parameter_order": [
      "data",
      "min",
      "max"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "min": {
        "description": "Minimum value. All values lower than this value will be set to the value of this parameter.",
        "schema": {
          "type": "number"
        },
        "required": true
      },
      "max": {
        "description": "Maximum value. All values greater than this value will be set to the value of this parameter.",
        "schema": {
          "type": "number"
        },
        "required": true
      }
    },
    "returns": {
      "description": "An array with the values clipped to the specified range.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            -2,
            -1,
            0,
            1,
            2
          ],
          "min": -1,
          "max": 1
        },
        "returns": [
          -1,
          -1,
          0,
          1,
          1
        ]
      },
      {
        "arguments": {
          "data": [
            -0.1,
            -0.001,
            null,
            0,
            0.25,
            0.75,
            1.001,
            null
          ],
          "min": 0,
          "max": 1
        },
        "returns": [
          0,
          0,
          null,
          0,
          0.25,
          0.75,
          1,
          null
        ]
      }
    ]
  },
  {
    "id": "cos",
    "summary": "Cosine",
    "description": "Computes the cosine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed cosine of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 1
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Cosine.html",
        "title": "Cosine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "cosh",
    "summary": "Hyperbolic cosine",
    "description": "Computes the hyperbolic cosine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed hyperbolic cosine of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 1
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/HyperbolicCosine.html",
        "title": "Hyperbolic cosine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "count",
    "summary": "Count the number of elements",
    "description": "Gives the number of elements in an array that matches a certain criterion / expression.\n\n**Remarks:**\n\n* By default counts the number of valid elements. A valid element is every element for which ``is_valid()`` returns `true`.\n* To count all elements in a list set the `expression` parameter to boolean `true`.",
    "categories": [
      "arrays",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "expression"
    ],
    "parameters": {
      "data": {
        "description": "An array with elements of any data type.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        },
        "required": true
      },
      "expression": {
        "description": "An expression that is evaluated against each element in the array. An element is counted only if the expression returns `true`. Defaults to count valid elements in a list (see ``is_valid()``). Setting this parameter to boolean `true` counts all elements in the list.",
        "schema": {
          "anyOf": [
            {
              "description": "An expression that is evaluated against each element in the array.",
              "type": "object",
              "format": "callback",
              "parameters": {
                "x": {
                  "description": "A single value from the array. Any data type could be passed."
                }
              }
            },
            {
              "description": "Boolean `true` counts all elements in the list.",
              "type": "boolean",
              "const": true
            },
            {
              "description": "`null` counts valid elements in the list.",
              "type": "null"
            }
          ],
          "default": null
        }
      }
    },
    "returns": {
      "description": "The counted number of elements.",
      "schema": {
        "type": "number"
      }
    },
    "examples": [
      {
        "arguments": {
          "data": []
        },
        "returns": 0
      },
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 4
      },
      {
        "arguments": {
          "data": [
            "ABC",
            null
          ]
        },
        "returns": 1
      },
      {
        "arguments": {
          "data": [
            false,
            null
          ],
          "expression": true
        },
        "returns": 2
      },
      {
        "arguments": {
          "data": [
            0,
            1,
            2,
            3,
            4,
            5,
            null
          ],
          "expression": {
            "gt": {
              "process_id": "gt",
              "arguments": {
                "x": {
                  "from_argument": "element"
                },
                "y": 2
              },
              "result": true
            }
          }
        },
        "returns": 3
      }
    ]
  },
  {
    "id": "create_raster_cube",
    "summary": "Create an empty raster data cube",
    "description": "Creates a new raster data cube without dimensions.",
    "categories": [
      "cubes"
    ],
    "parameters": {},
    "returns": {
      "description": "An empty raster data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "cummax",
    "summary": "Cumulative maxima",
    "description": "Finds cumulative maxima of an array of numbers. Every computed element is equal to the bigger one between current element and the previously computed element. The returned array and the input array have always the same length.\n\nBy default, no-data values are skipped, but stay in the result. Setting the `ignore_nodata` flag to `true` makes that once a no-data value / `null` is reached all following elements are set to `null` in the result.",
    "categories": [
      "math > cumulative"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is set for all the following elements.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "An array with the computed cumulative maxima.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            3,
            5,
            3,
            1
          ]
        },
        "returns": [
          1,
          3,
          5,
          5,
          5
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            3,
            null,
            5,
            1
          ]
        },
        "returns": [
          1,
          3,
          null,
          5,
          5
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            3,
            null,
            5,
            1
          ],
          "ignore_nodata": false
        },
        "returns": [
          1,
          3,
          null,
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "cummin",
    "summary": "Cumulative minima",
    "description": "Finds cumulative minima of an array of numbers. Every computed element is equal to the smaller one between current element and the previously computed element. The returned array and the input array have always the same length.\n\nBy default, no-data values are skipped, but stay in the result. Setting the `ignore_nodata` flag to `true` makes that once a no-data value / `null` is reached all following elements are set to `null` in the result.",
    "categories": [
      "math > cumulative"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is set for all the following elements.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "An array with the computed cumulative minima.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            5,
            3,
            1,
            3,
            5
          ]
        },
        "returns": [
          5,
          3,
          1,
          1,
          1
        ]
      },
      {
        "arguments": {
          "data": [
            5,
            3,
            null,
            1,
            5
          ]
        },
        "returns": [
          5,
          3,
          null,
          1,
          1
        ]
      },
      {
        "arguments": {
          "data": [
            5,
            3,
            null,
            1,
            5
          ],
          "ignore_nodata": false
        },
        "returns": [
          5,
          3,
          null,
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "cumproduct",
    "summary": "Cumulative products",
    "description": "Computes cumulative products of an array of numbers. Every computed element is equal to the product of current and all previous values. The returned array and the input array have always the same length.\n\nBy default, no-data values are skipped, but stay in the result. Setting the `ignore_nodata` flag to `true` makes that once a no-data value / `null` is reached all following elements are set to `null` in the result.",
    "categories": [
      "math > cumulative"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is set for all the following elements.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "An array with the computed cumulative products.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            3,
            5,
            3,
            1
          ]
        },
        "returns": [
          1,
          3,
          15,
          45,
          45
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3,
            null,
            3,
            1
          ]
        },
        "returns": [
          1,
          2,
          6,
          null,
          18,
          18
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3,
            null,
            3,
            1
          ],
          "ignore_nodata": false
        },
        "returns": [
          1,
          2,
          6,
          null,
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "cumsum",
    "summary": "Cumulative sums",
    "description": "Computes cumulative sums of an array of numbers. Every computed element is equal to the sum of current and all previous values. The returned array and the input array have always the same length.\n\nBy default, no-data values are skipped, but stay in the result. Setting the `ignore_nodata` flag to `true` makes that once a no-data value / `null` is reached all following elements are set to `null` in the result.",
    "categories": [
      "math > cumulative"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is set for all the following elements.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "An array with the computed cumulative sums.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            3,
            5,
            3,
            1
          ]
        },
        "returns": [
          1,
          4,
          9,
          12,
          13
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            3,
            null,
            3,
            1
          ]
        },
        "returns": [
          1,
          4,
          null,
          7,
          8
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            3,
            null,
            3,
            1
          ],
          "ignore_nodata": false
        },
        "returns": [
          1,
          4,
          null,
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "debug",
    "summary": "Send debugging information to subscribed clients",
    "description": "Sends debugging information about the data to clients, which are subscribed to the topic `openeo.jobs.debug`.",
    "categories": [
      "development"
    ],
    "experimental": true,
    "parameter_order": [
      "data",
      "id"
    ],
    "parameters": {
      "data": {
        "description": "Data to send.",
        "schema": {
          "description": "Any data type is allowed."
        },
        "required": true
      },
      "id": {
        "description": "An identifier to help identify the message in a bunch of other messages.",
        "schema": {
          "type": "string",
          "default": ""
        }
      }
    },
    "returns": {
      "description": "`false` if the information could not be sent, `true` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/apireference-subscriptions/#publish-openeojobsdebug",
        "title": "Information about the openEO API for Subscriptions"
      }
    ]
  },
  {
    "id": "divide",
    "summary": "Division of a sequence of numbers",
    "description": "Divides the first element in a sequential array of numbers by all other elements.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) so that for example a division by zero should result in infinity if the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nBy default no-data values are ignored. Setting `ignore_nodata` to `false` considers no-data values so that `null` is returned if any element is such a value.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers with at least two elements.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          },
          "minItems": 2
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed result of the sequence of numbers.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "exceptions": {
      "DivisorMissing": {
        "message": "Division requires at least two numbers (a dividend and one or more divisors)."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            15,
            5
          ]
        },
        "returns": 3
      },
      {
        "arguments": {
          "data": [
            -2,
            4,
            2.5
          ]
        },
        "returns": -0.2
      },
      {
        "arguments": {
          "data": [
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Division.html",
        "title": "Division explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "e",
    "summary": "Euler's number (e)",
    "description": "The real number *e* is a mathematical constant that is the base of the natural logarithm such that *ln(e) = 1*. The numerical value is approximately *2.71828*.",
    "categories": [
      "math > constants",
      "math > exponential & logarithmic"
    ],
    "parameters": {},
    "returns": {
      "description": "The numerical value of Euler's number.",
      "schema": {
        "type": "number"
      }
    },
    "examples": [
      {
        "title": "Test for ln(e) = 1",
        "process_graph": {
          "e1": {
            "process_id": "e",
            "arguments": {}
          },
          "ln1": {
            "process_id": "ln",
            "arguments": {
              "data": {
                "from_node": "e1"
              }
            },
            "result": true
          }
        },
        "returns": 1
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/e.html",
        "title": "Mathematical constant e explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "eq",
    "summary": "Equal to comparison",
    "description": "Compares whether `x` is strictly equal to `y`.\n\n**Remarks:**\n\n* Data types MUST be checked strictly, for example a string with the content *1* is not equal to the number *1*. Nevertheless, an integer *1* is equal to a floating point number *1.0* as `integer` is a sub-type of `number`.\n* If any of the operands is `null`, the return value is `null`.\n* Strings are expected to be encoded in UTF-8 by default.\n* Temporal strings MUST be compared differently than other strings and MUST NOT be compared based on their string representation due to different possible representations. For example, the UTC time zone representation `Z` has the same meaning as `+00:00`.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameter_order": [
      "x",
      "y",
      "delta",
      "case_sensitive"
    ],
    "parameters": {
      "x": {
        "description": "First operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "boolean"
            },
            {
              "type": "null"
            },
            {
              "type": "string"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "y": {
        "description": "Second operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "boolean"
            },
            {
              "type": "null"
            },
            {
              "type": "string"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "delta": {
        "description": "Only applicable for comparing two numbers. If this optional parameter is set to a positive non-zero number the equality of two numbers is checked against a delta value. This is especially useful to circumvent problems with floating point inaccuracy in machine-based computation.\n\nThis option is basically an alias for the following computation: `lte(abs(minus([x, y]), delta)`",
        "schema": {
          "type": [
            "number",
            "null"
          ],
          "default": null
        }
      },
      "case_sensitive": {
        "description": "Only applicable for comparing two strings. Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "Returns `true` if `x` is equal to `y`, `null` if any of the operands is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 1,
          "y": 1
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 1,
          "y": "1"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 1.02,
          "y": 1,
          "delta": 0.01
        },
        "returns": false
      },
      {
        "arguments": {
          "x": -1,
          "y": -1.001,
          "delta": 0.01
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 115,
          "y": 110,
          "delta": 10
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "Test",
          "y": "test"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "Test",
          "y": "test",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "",
          "y": "",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "00:00:00+00:00",
          "y": "00:00:00Z"
        },
        "returns": true
      },
      {
        "description": "`y` is not a valid date-time representation and therefore will be treated as a string so that the provided values are not equal.",
        "arguments": {
          "x": "2018-01-01T12:00:00Z",
          "y": "2018-01-01T12:00:00"
        },
        "returns": false
      },
      {
        "description": "01:00 in the time zone +1 is equal to 00:00 in UTC.",
        "arguments": {
          "x": "2018-01-01T00:00:00Z",
          "y": "2018-01-01T01:00:00+01:00"
        },
        "returns": true
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      }
    ]
  },
  {
    "id": "exp",
    "summary": "Exponentiation to the base e",
    "description": "Exponential function to the base *e* raised to the power of `p`. This process is an alias for *e^p^* / `power(e(), p)`.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > exponential & logarithmic"
    ],
    "parameters": {
      "p": {
        "description": "The numerical exponent.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed value for *e* raised to the power of `p`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "p": 0
        },
        "returns": 1
      },
      {
        "arguments": {
          "p": null
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/ExponentialFunction.html",
        "title": "Exponential function explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "extrema",
    "summary": "Minimum and maximum values",
    "description": "Two element array containing the minimum and the maximum values of `data`.\n\nThis process is basically an alias for calling both ``min()`` and ``max()``, but may be implemented more performant by back-ends as it only needs to iterate over the data once instead of twice.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that an array with two `null` values is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "An array containing the minimum and maximum values for the specified numbers. The first element is the minimum, the second element is the maximum. If the input array is empty both elements are set to `null`.",
      "schema": {
        "anyOf": [
          {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "type": [
                "number"
              ]
            }
          },
          {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "type": [
                "null"
              ]
            }
          }
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": [
          0,
          3
        ]
      },
      {
        "arguments": {
          "data": [
            5,
            2.5,
            null,
            -0.7
          ]
        },
        "returns": [
          -0.7,
          5
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            null,
            2
          ],
          "ignore_nodata": false
        },
        "returns": [
          null,
          null
        ]
      },
      {
        "description": "The input array is empty: return two `null` values.",
        "arguments": {
          "data": []
        },
        "returns": [
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "filter_bands",
    "summary": "Filter the bands by name",
    "description": "Filters the bands in the data cube so that bands that don't match any of the criteria are dropped from the data cube. The data cube is expected to have only one dimension of type `bands`. Fails with a `DimensionMissing` error if no such dimension exists.\n\nThe following criteria can be used to select bands:\n\n* `bands`: band name (e.g. `B01` or `B8A`)\n* `common_names`: common band names (e.g. `red` or `nir`)\n* `wavelengths`: ranges of wavelengths in micrometres (m) (e.g. 0.5 - 0.6)\n\nTo keep algorithms interoperable it is recommended to prefer the common bands names or the wavelengths over collection and/or back-end specific band names.\n\nIf multiple criteria are specified, any of them must match and not all of them, i.e. they are combined with an OR-operation. If no criteria is specified, the `BandFilterParameterMissing` exception must be thrown.\n\n**Important:** The order of the specified array defines the order of the bands in the data cube, which can be important for subsequent processes. If multiple bands are matched by a single criterion (e.g. a range of wavelengths), they are ordered alphabetically by band names. Bands without names have an arbitrary order.",
    "categories": [
      "filter"
    ],
    "parameter_order": [
      "data",
      "bands",
      "common_names",
      "wavelengths"
    ],
    "parameters": {
      "data": {
        "description": "A data cube with bands.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "bands": {
        "description": "A list of band names.\n\nThe order of the specified array defines the order of the bands in the data cube.",
        "schema": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "band-name"
          }
        }
      },
      "common_names": {
        "description": "A list of common band names.\n\nThe order of the specified array defines the order of the bands in the data cube.",
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "wavelengths": {
        "description": "A list of sub-lists with each sub-list consisting of two elements. The first element is the minimum wavelength and the second element is the maximum wavelength. Wavelengths are specified in micrometres (m).\n\nThe order of the specified array defines the order of the bands in the data cube.",
        "schema": {
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "type": "number"
            },
            "examples": [
              [
                [
                  0.45,
                  0.5
                ],
                [
                  0.6,
                  0.7
                ]
              ]
            ]
          }
        }
      }
    },
    "returns": {
      "description": "A data cube limited to a subset of its original bands. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "exceptions": {
      "BandFilterParameterMissing": {
        "message": "The process 'filter_bands' requires any of the parameters 'bands', 'common_names' or 'wavelengths' to be set."
      },
      "DimensionMissing": {
        "message": "A band dimension is missing."
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://github.com/radiantearth/stac-spec/tree/master/extensions/eo#common-band-names",
        "title": "List of common band names as specified by the STAC specification"
      }
    ]
  },
  {
    "id": "filter_bbox",
    "summary": "Spatial filter using a bounding box",
    "description": "Limits the data cube to the specified bounding box.\n\nThe filter retains a pixel in the data cube if the point at the pixel center intersects with the bounding box (as defined in the Simple Features standard by the OGC).",
    "categories": [
      "filter"
    ],
    "parameter_order": [
      "data",
      "extent"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "extent": {
        "description": "A bounding box, which may include a vertical axis (see `base` and `height`).\n\nThe coordinate reference system of the extent must be specified as [EPSG](http://www.epsg.org) code or [PROJ](https://proj4.org) definition.",
        "required": true,
        "schema": {
          "type": "object",
          "format": "bounding-box",
          "required": [
            "west",
            "south",
            "east",
            "north"
          ],
          "properties": {
            "west": {
              "description": "West (lower left corner, coordinate axis 1).",
              "type": "number"
            },
            "south": {
              "description": "South (lower left corner, coordinate axis 2).",
              "type": "number"
            },
            "east": {
              "description": "East (upper right corner, coordinate axis 1).",
              "type": "number"
            },
            "north": {
              "description": "North (upper right corner, coordinate axis 2).",
              "type": "number"
            },
            "base": {
              "description": "Base (optional, lower left corner, coordinate axis 3).",
              "type": [
                "number",
                "null"
              ],
              "default": null
            },
            "height": {
              "description": "Height (optional, upper right corner, coordinate axis 3).",
              "type": [
                "number",
                "null"
              ],
              "default": null
            },
            "crs": {
              "description": "Coordinate reference system of the extent specified as EPSG code or PROJ definition. Whenever possible, it is recommended to use EPSG codes instead of PROJ definitions. Defaults to `4326` (EPSG code 4326) unless the client explicitly requests a different coordinate reference system.",
              "schema": {
                "anyOf": [
                  {
                    "title": "EPSG Code",
                    "type": "integer",
                    "format": "epsg-code",
                    "examples": [
                      7099
                    ]
                  },
                  {
                    "title": "PROJ definition",
                    "type": "string",
                    "format": "proj-definition",
                    "examples": [
                      "+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
                    ]
                  }
                ],
                "default": 4326
              }
            }
          }
        }
      }
    },
    "returns": {
      "description": "A data cube restricted to the bounding box. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://proj4.org/usage/projections.html",
        "title": "PROJ parameters for cartographic projections"
      },
      {
        "rel": "about",
        "href": "http://www.epsg-registry.org",
        "title": "Official EPSG code registry"
      },
      {
        "rel": "about",
        "href": "http://www.epsg.io",
        "title": "Unofficial EPSG code database"
      },
      {
        "href": "http://www.opengeospatial.org/standards/sfa",
        "rel": "about",
        "title": "Simple Features standard by the OGC"
      }
    ]
  },
  {
    "id": "filter_polygon",
    "summary": "Spatial filter using polygons",
    "description": "Limits the data cube over the spatial dimensions to the specified polygons.\n\nThe filter retains a pixel in the data cube if the point at the pixel center intersects with at least one of the polygons (as defined in the Simple Features standard by the OGC).",
    "categories": [
      "filter"
    ],
    "parameter_order": [
      "data",
      "polygons"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "polygons": {
        "description": "One or more polygons used for filtering, either specified as GeoJSON or vector data cube.\n\nFor GeoJSON this can be one of the following GeoJSON types:\n\n* A `Polygon` geometry,\n* a `GeometryCollection` containing Polygons,\n* a `Feature` with a `Polygon` geometry or\n* a `FeatureCollection` containing `Feature`s with a `Polygon` geometry.",
        "schema": {
          "anyOf": [
            {
              "type": "object",
              "format": "geojson"
            },
            {
              "type": "object",
              "format": "vector-cube"
            }
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "A data cube restricted to the specified polygons. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "links": [
      {
        "href": "http://www.opengeospatial.org/standards/sfa",
        "rel": "about",
        "title": "Simple Features standard by the OGC"
      }
    ]
  },
  {
    "id": "filter_temporal",
    "summary": "Temporal filter for a date and/or time intervals",
    "description": "Limits the data cube to the specified interval of dates and/or times.\n\nMore precisely, the filter checks whether the temporal dimension value is greater than or equal to the lower boundary (start date/time) and the temporal dimension value is less than the value of the upper boundary (end date/time). This corresponds to a left-closed interval, which contains the lower boundary but not the upper boundary.\n\nIf the dimension is set to `null` (it's the default value), the data cube is expected to only have one temporal dimension.",
    "categories": [
      "filter"
    ],
    "parameter_order": [
      "data",
      "extent",
      "dimension"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "extent": {
        "description": "Left-closed temporal interval, i.e. an array with exactly two elements:\n\n1. The first element is the start of the date and/or time interval. The specified instance in time is **included** in the interval.\n2. The second element is the end of the date and/or time interval. The specified instance in time is **excluded** from the interval.\n\nThe specified temporal strings follow [RFC 3339](https://tools.ietf.org/html/rfc3339). Although [RFC 3339 prohibits the hour to be '24'](https://tools.ietf.org/html/rfc3339#section-5.7), **this process allows the value '24' for the hour** of an end time in order to make it possible that left-closed time intervals can fully cover the day.\n\nAlso supports open intervals by setting one of the boundaries to `null`, but never both.",
        "schema": {
          "type": "array",
          "format": "temporal-interval",
          "minItems": 2,
          "maxItems": 2,
          "items": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "string",
                "format": "date"
              },
              {
                "type": "string",
                "format": "time"
              },
              {
                "type": "null"
              }
            ]
          },
          "examples": [
            [
              "2015-01-01",
              "2016-01-01"
            ],
            [
              "12:00:00Z",
              "24:00:00Z"
            ]
          ]
        },
        "required": true
      },
      "dimension": {
        "description": "The temporal dimension to filter on. If the dimension is not set or is set to `null`, the data cube is expected to only have one temporal dimension. Fails with a `TooManyDimensions` error if it has more dimensions. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Note:** The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.",
        "schema": {
          "type": [
            "string",
            "null"
          ],
          "default": null
        }
      }
    },
    "returns": {
      "description": "A data cube restricted to the specified temporal extent. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "exceptions": {
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      },
      "TooManyDimensions": {
        "message": "The number of temporal dimensions must be reduced to one for 'filter_temporal'."
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      }
    ]
  },
  {
    "id": "filter",
    "summary": "Filter based on a logical expression.",
    "description": "Filters the dimension values based on a logical expression so that afterwards each dimension value in the data cube conforms to the expression.",
    "categories": [
      "cubes",
      "filter"
    ],
    "parameter_order": [
      "data",
      "expression",
      "dimension"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "expression": {
        "description": "An expression that is evaluated against each dimension value in the specified dimension. A dimension value is dropped from the data cube if the expression returns `false`. The data type of the parameter depends on the dimension values stored for the dimension.",
        "schema": {
          "type": "object",
          "format": "callback",
          "parameters": {
            "value": {
              "description": "A single dimension value to compare against.",
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "string",
                  "format": "date"
                },
                {
                  "type": "string",
                  "format": "time"
                }
              ]
            }
          }
        },
        "required": true
      },
      "dimension": {
        "description": "The dimension to filter on. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Remarks:**\n\n* The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.\n* There could be multiple spatial dimensions such as `x`, `y` or `z`.\n* For multi-spectral imagery there is usually a separate dimension of type `bands` for the bands.",
        "schema": {
          "type": "string"
        },
        "required": true
      }
    },
    "returns": {
      "description": "A data cube restricted by the specified expression. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "exceptions": {
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      }
    }
  },
  {
    "id": "find_collections",
    "summary": "Search for collections by metadata properties",
    "description": "Searches for collections available on the current back-end by metadata properties and returns ids of collections that match all criteria. ``property()`` can be used to get metadata properties.\n\nA single collection can be selected using array operations such as ``first()``, ``last()`` and ``array_element()`` and afterwards be loaded using ``load_collection()``.",
    "categories": [
      "cubes",
      "import"
    ],
    "experimental": true,
    "parameters": {
      "expression": {
        "description": "An expression that is evaluated against each collection the back-end offers. The expression filters the collections to include only collection ids which the given expression returns `true` for. ``property()`` can be used to retrieve metadata properties.",
        "schema": {
          "type": "object",
          "format": "callback",
          "parameters": {
            "id": {
              "description": "The collection id.",
              "type": "string",
              "format": "collection-id",
              "pattern": "^[A-Za-z0-9_\\-\\.~/]+$"
            }
          }
        },
        "required": true
      }
    },
    "returns": {
      "description": "An array of collection ids.",
      "schema": {
        "type": "array",
        "items": {
          "type": "string",
          "format": "collection-id",
          "pattern": "^[A-Za-z0-9_\\-\\.~/]+$"
        }
      }
    }
  },
  {
    "id": "first",
    "summary": "First element",
    "description": "Gives the first element of an array. For an empty array `null` is returned.",
    "categories": [
      "arrays",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array with elements of any data type. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if the first value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The first element of the input array.",
      "schema": {
        "description": "Any data type is allowed."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 1
      },
      {
        "arguments": {
          "data": [
            null,
            "A",
            "B"
          ]
        },
        "returns": "A"
      },
      {
        "arguments": {
          "data": [
            null,
            2,
            3
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ]
  },
  {
    "id": "floor",
    "summary": "Round fractions down",
    "description": "The greatest integer less than or equal to the number `x`.\n\nThis process is *not* an alias for the `int` process as defined by some mathematicians, see the examples for negative numbers in both processes for differences.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > rounding"
    ],
    "parameters": {
      "x": {
        "description": "A number to round down.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The number rounded down.",
      "schema": {
        "type": [
          "integer",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 3
      },
      {
        "arguments": {
          "x": -0.4
        },
        "returns": -1
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": -4
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/FloorFunction.html",
        "title": "Floor explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "gt",
    "summary": "Greater than comparison",
    "description": "Compares whether `x` is strictly greater than `y`.\n\n**Remarks:**\n\n* If any of the operands is `null`, the return value is `null`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.\n* Comparing strings is currently not supported, but is planned to be added in the future.",
    "categories": [
      "comparison"
    ],
    "parameter_order": [
      "x",
      "y"
    ],
    "parameters": {
      "x": {
        "description": "First operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "y": {
        "description": "Second operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if `x` is strictly greater than `y` or `null` if any of the operands is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 0,
          "y": 0
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 2,
          "y": 1
        },
        "returns": true
      },
      {
        "arguments": {
          "x": -0.5,
          "y": -0.6
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "00:00:00Z",
          "y": "00:00:00+01:00"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "1950-01-01T00:00:00Z",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "2018-01-01T12:00:00+00:00",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": false
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      }
    ]
  },
  {
    "id": "gte",
    "summary": "Greater than or equal to comparison",
    "description": "Compares whether `x` is greater than or equal to `y`.\n\n**Remarks:**\n\n* If any of the operands is `null`, the return value is `null`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.\n* Comparing strings is currently not supported, but is planned to be added in the future.",
    "categories": [
      "comparison"
    ],
    "parameter_order": [
      "x",
      "y"
    ],
    "parameters": {
      "x": {
        "description": "First operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "y": {
        "description": "Second operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if `x` is greater than or equal to `y` or `null` if any of the operands is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 0,
          "y": 0
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 1,
          "y": 2
        },
        "returns": false
      },
      {
        "arguments": {
          "x": -0.5,
          "y": -0.6
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "00:00:00Z",
          "y": "00:00:00+01:00"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "1950-01-01T00:00:00Z",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "2018-01-01T12:00:00+00:00",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": true
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      }
    ]
  },
  {
    "id": "if",
    "summary": "If-Then-Else conditional",
    "description": "Returns the value of the `accept` parameter if the expression is `true` or the value of the `reject` parameter if the expression is `false`. This works similar to an if-then-else construct.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "logic",
      "comparison",
      "masks"
    ],
    "parameter_order": [
      "expression",
      "accept",
      "reject"
    ],
    "parameters": {
      "expression": {
        "description": "A boolean value.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ]
        },
        "required": true
      },
      "accept": {
        "description": "A value that is returned if the boolean expression is `true`. Defaults to `true`.",
        "schema": {
          "description": "Any data type is allowed.",
          "default": true
        }
      },
      "reject": {
        "description": "A value that is returned if the boolean expression is `false`. Defaults to `false`.",
        "schema": {
          "description": "Any data type is allowed.",
          "default": false
        }
      }
    },
    "returns": {
      "description": "Either the `accept` or `reject` argument depending on the given boolean expression.",
      "schema": {
        "description": "Any data type is allowed."
      }
    },
    "examples": [
      {
        "arguments": {
          "expression": true
        },
        "returns": true
      },
      {
        "arguments": {
          "expression": null
        },
        "returns": null
      },
      {
        "arguments": {
          "expression": false
        },
        "returns": false
      },
      {
        "arguments": {
          "expression": true,
          "accept": "A"
        },
        "returns": "A"
      },
      {
        "arguments": {
          "expression": false,
          "accept": [
            1,
            2,
            3
          ],
          "reject": [
            4,
            5,
            6
          ]
        },
        "returns": [
          4,
          5,
          6
        ]
      }
    ]
  },
  {
    "id": "int",
    "summary": "Integer part of a number",
    "description": "The integer part of the real number `x`.\n\nThis process is *not* an alias for the `floor` process as defined by some mathematicians, see the examples for negative numbers in both processes for differences.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math",
      "math > rounding"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "Integer part of the number.",
      "schema": {
        "type": [
          "integer",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 3
      },
      {
        "arguments": {
          "x": -0.4
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": -3
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/IntegerPart.html",
        "title": "Integer Part explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "is_nan",
    "summary": "Value is not a number",
    "description": "Checks whether the specified value `x` is not a number (often abbreviated as `NaN`). The definition of `NaN` follows the [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935). All non-numeric data types MUST also return `true`.",
    "categories": [
      "comparison"
    ],
    "parameters": {
      "x": {
        "description": "The data to check.",
        "schema": {
          "description": "Any data type is allowed."
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if the data is not a number, otherwise `false`",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "Test"
        },
        "returns": true
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "is_nodata",
    "summary": "Value is not a no-data value",
    "description": "Checks whether the specified data is a missing data, i.e. equals to any of the no-data values / `null`.",
    "categories": [
      "comparison"
    ],
    "parameters": {
      "x": {
        "description": "The data to check.",
        "schema": {
          "description": "Any data type is allowed."
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if the data is a no-data value, otherwise `false`",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "Test"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": null
        },
        "returns": true
      }
    ]
  },
  {
    "id": "is_valid",
    "summary": "Value is valid data",
    "description": "Checks whether the specified value `x` is valid. A value is considered valid if it is\n\n1. not a no-data value (`null`) and\n2. a finite number (only if `x` is a number). The definition of finite and infinite numbers follows the [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935).",
    "categories": [
      "comparison"
    ],
    "parameters": {
      "x": {
        "description": "The data to check.",
        "schema": {
          "description": "Any data type is allowed."
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if the data is valid, otherwise `false`.",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "Test"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": null
        },
        "returns": false
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "last",
    "summary": "Last element",
    "description": "Gives the last element of an array. For an empty array `null` is returned.",
    "categories": [
      "arrays",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array with elements of any data type. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if the last value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The last element of the input array.",
      "schema": {
        "description": "Any data type is allowed."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 2
      },
      {
        "arguments": {
          "data": [
            "A",
            "B",
            null
          ]
        },
        "returns": "B"
      },
      {
        "arguments": {
          "data": [
            0,
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ]
  },
  {
    "id": "linear_scale_range",
    "summary": "Linear transformation between two ranges",
    "description": "Performs a linear transformation between the input and output range.\n\nThe underlying formula is: `((x - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin`.\n\nPotential use case include\n\n* scaling values to the 8-bit range (0 - 255) often used for numeric representation of values in one of the channels of the [RGB colour model](https://en.wikipedia.org/wiki/RGB_color_model#Numeric_representations) or\n* calculating percentages (0 - 100).\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math"
    ],
    "parameter_order": [
      "x",
      "inputMin",
      "inputMax",
      "outputMin",
      "outputMax"
    ],
    "parameters": {
      "x": {
        "description": "A number to transform.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      },
      "inputMin": {
        "description": "Minimum value the input can obtain.",
        "schema": {
          "type": "number"
        },
        "required": true
      },
      "inputMax": {
        "description": "Maximum value the input can obtain.",
        "schema": {
          "type": "number"
        },
        "required": true
      },
      "outputMin": {
        "description": "Minimum value of the desired output range.",
        "schema": {
          "type": "number",
          "default": 0
        }
      },
      "outputMax": {
        "description": "Maximum value of the desired output range.",
        "schema": {
          "type": "number",
          "default": 1
        }
      }
    },
    "returns": {
      "description": "The transformed number.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0.3,
          "inputMin": -1,
          "inputMax": 1,
          "outputMin": 0,
          "outputMax": 255
        },
        "returns": 165.75
      },
      {
        "arguments": {
          "x": 25.5,
          "inputMin": 0,
          "inputMax": 255
        },
        "returns": 0.1
      },
      {
        "arguments": {
          "x": null,
          "inputMin": 0,
          "inputMax": 100
        },
        "returns": null
      }
    ]
  },
  {
    "id": "ln",
    "summary": "Natural logarithm",
    "description": "The natural logarithm is the logarithm to the base *e* of the number `x`. This process is an alias for the *log* process with the base set to *e*: `log(x, e())`. The natural logarithm is the inverse function of taking *e* to the power x.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) so that for example `ln(0)` should result in infinity if the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > exponential & logarithmic"
    ],
    "parameters": {
      "x": {
        "description": "A number to compute the natural logarithm for.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed natural logarithm.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "title": "Example for ln(e) = 1",
        "process_graph": {
          "e1": {
            "process_id": "e",
            "arguments": {}
          },
          "ln1": {
            "process_id": "ln",
            "arguments": {
              "data": {
                "from_node": "e1"
              }
            },
            "result": true
          }
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 1
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/NaturalLogarithm.html",
        "title": "Natural logarithm explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "load_collection",
    "summary": "Load a collection",
    "description": "Loads a collection from the current back-end by its id and returns it as processable data cube. The data that is added to the data cube can be restricted with the additional `spatial_extent`, `temporal_extent`, `bands` and `properties`.\n\n**Remarks:**\n\n* The bands (and all dimensions that specify nominal dimension values) are expected to be ordered as specified in the metadata if the `bands` parameter is set to `null`.\n* If no additional parameter is specified this would imply that the whole data set is expected to be loaded. Due to the large size of many data sets this is not recommended and may be optimized by back-ends to only load the data that is actually required after evaluating subsequent processes such as filters. This means that the pixel values should be processed only after the data has been limited to the required extents and as a consequence also to a manageable size.",
    "categories": [
      "cubes",
      "import"
    ],
    "parameter_order": [
      "id",
      "spatial_extent",
      "temporal_extent",
      "bands",
      "properties"
    ],
    "parameters": {
      "id": {
        "description": "The collection id.",
        "schema": {
          "type": "string",
          "format": "collection-id",
          "pattern": "^[A-Za-z0-9_\\-\\.~/]+$"
        },
        "required": true
      },
      "spatial_extent": {
        "description": "Limits the data to load from the collection to the specified bounding box or polygons.\n\nThe process puts a pixel into the data cube if the point at the pixel center intersects with the bounding box or any of the polygons (as defined in the Simple Features standard by the OGC).\n\nThe coordinate reference system of the bounding box must be specified as [EPSG](http://www.epsg.org) code or [PROJ](https://proj4.org) definition.\n\nThe GeoJSON can be one of the following GeoJSON types:\n\n* A `Polygon` geometry,\n* a `GeometryCollection` containing Polygons,\n* a `Feature` with a `Polygon` geometry or\n* a `FeatureCollection` containing `Feature`s with a `Polygon` geometry.\n\nSet this parameter to `null` to set no limit for the spatial extent. Be careful with this when loading large datasets!",
        "schema": {
          "anyOf": [
            {
              "title": "Bounding Box",
              "type": "object",
              "format": "bounding-box",
              "required": [
                "west",
                "south",
                "east",
                "north"
              ],
              "properties": {
                "west": {
                  "description": "West (lower left corner, coordinate axis 1).",
                  "type": "number"
                },
                "south": {
                  "description": "South (lower left corner, coordinate axis 2).",
                  "type": "number"
                },
                "east": {
                  "description": "East (upper right corner, coordinate axis 1).",
                  "type": "number"
                },
                "north": {
                  "description": "North (upper right corner, coordinate axis 2).",
                  "type": "number"
                },
                "base": {
                  "description": "Base (optional, lower left corner, coordinate axis 3).",
                  "type": [
                    "number",
                    "null"
                  ],
                  "default": null
                },
                "height": {
                  "description": "Height (optional, upper right corner, coordinate axis 3).",
                  "type": [
                    "number",
                    "null"
                  ],
                  "default": null
                },
                "crs": {
                  "description": "Coordinate reference system of the extent specified as EPSG code or PROJ definition. Whenever possible, it is recommended to use EPSG codes instead of PROJ definitions. Defaults to `4326` (EPSG code 4326) unless the client explicitly requests a different coordinate reference system.",
                  "schema": {
                    "anyOf": [
                      {
                        "title": "EPSG Code",
                        "type": "integer",
                        "format": "epsg-code",
                        "examples": [
                          7099
                        ]
                      },
                      {
                        "title": "PROJ definition",
                        "type": "string",
                        "format": "proj-definition",
                        "examples": [
                          "+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
                        ]
                      }
                    ],
                    "default": 4326
                  }
                }
              }
            },
            {
              "title": "GeoJSON Polygon(s)",
              "type": "object",
              "format": "geojson"
            },
            {
              "type": "null"
            }
          ]
        },
        "required": true
      },
      "temporal_extent": {
        "description": "Limits the data to load from the collection to the specified left-closed temporal interval. Applies to all temporal dimensions if there are multiple of them. The interval has to be specified as an array with exactly two elements:\n\n1. The first element is the start of the date and/or time interval. The specified instance in time is **included** in the interval.\n2. The second element is the end of the date and/or time interval. The specified instance in time is **excluded** from the interval.\n\nThe specified temporal strings follow [RFC 3339](https://tools.ietf.org/html/rfc3339). Although [RFC 3339 prohibits the hour to be '24'](https://tools.ietf.org/html/rfc3339#section-5.7), **this process allows the value '24' for the hour** of an end time in order to make it possible that left-closed time intervals can fully cover the day.\n\nAlso supports open intervals by setting one of the boundaries to `null`, but never both.\n\nSet this parameter to `null` to set no limit for the spatial extent. Be careful with this when loading large datasets!",
        "schema": {
          "anyOf": [
            {
              "type": "array",
              "format": "temporal-interval",
              "minItems": 2,
              "maxItems": 2,
              "items": {
                "anyOf": [
                  {
                    "type": "string",
                    "format": "date-time"
                  },
                  {
                    "type": "string",
                    "format": "date"
                  },
                  {
                    "type": "string",
                    "format": "time"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "examples": [
                [
                  "2015-01-01",
                  "2016-01-01"
                ],
                [
                  "12:00:00Z",
                  "24:00:00Z"
                ]
              ]
            },
            {
              "type": "null"
            }
          ]
        },
        "required": true
      },
      "bands": {
        "description": "Only adds the specified bands into the data cube so that bands that don't match the list of band names are not available. Applies to all dimensions of type `bands` if there are multiple of them.\n\nThe order of the specified array defines the order of the bands in the data cube.",
        "schema": {
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "string",
                "format": "band-name"
              }
            },
            {
              "type": "null"
            }
          ],
          "default": "null"
        }
      },
      "properties": {
        "description": "Limits the data by metadata properties to include only data in the data cube which all given expressions return `true` for (AND operation).\n\nSpecify key-value-pairs with the keys being the name of the metadata property, which can be retrieved with the openEO Data Discovery for Collections. The values must be expressions to be evaluated against the collection metadata, see the example.\n\n**Note:** Back-ends may not pass the actual value to the expressions, but pass a proprietary index or a placeholder so that they can use the expressions to query against another data source. So debugging on the callback parameter `value` may lead to unexpected results.",
        "experimental": true,
        "schema": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "format": "callback",
                "parameters": {
                  "value": {
                    "description": "The property value. Any data type could be passed."
                  }
                }
              }
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      }
    },
    "returns": {
      "description": "A data cube for further processing.",
      "schema": {
        "anyOf": [
          {
            "type": "object",
            "format": "raster-cube"
          },
          {
            "type": "object",
            "format": "vector-cube"
          }
        ]
      }
    },
    "examples": [
      {
        "description": "Loading `Sentinel-2B` data from a `Sentinel-2` collection for 2018, but only with cloud cover between 0 and 10%.",
        "process_graph": {
          "loadco1": {
            "process_id": "load_collection",
            "arguments": {
              "id": "Sentinel-2",
              "spatial_extent": {
                "west": 16.1,
                "east": 16.6,
                "north": 48.6,
                "south": 47.2
              },
              "temporal_extent": [
                "2018-01-01",
                "2019-01-01"
              ],
              "properties": {
                "eo:cloud_cover": {
                  "callback": {
                    "cc": {
                      "process_id": "between",
                      "arguments": {
                        "x": {
                          "from_argument": "value"
                        },
                        "min": 0,
                        "max": 10
                      },
                      "result": true
                    }
                  }
                },
                "eo:platform": {
                  "callback": {
                    "pf": {
                      "process_id": "eq",
                      "arguments": {
                        "x": {
                          "from_argument": "value"
                        },
                        "y": "Sentinel-2B",
                        "case_sensitive": false
                      },
                      "result": true
                    }
                  }
                }
              }
            },
            "result": true
          }
        }
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://proj4.org/usage/projections.html",
        "title": "PROJ parameters for cartographic projections"
      },
      {
        "rel": "about",
        "href": "http://www.epsg-registry.org",
        "title": "Official EPSG code registry"
      },
      {
        "rel": "about",
        "href": "http://www.epsg.io",
        "title": "Unofficial EPSG code database"
      },
      {
        "href": "http://www.opengeospatial.org/standards/sfa",
        "rel": "about",
        "title": "Simple Features standard by the OGC"
      },
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      }
    ]
  },
  {
    "id": "load_result",
    "summary": "Load batch job results",
    "description": "Loads batch job results by job id from the local user workspace / data store. The job must have been stored by the authenticated user on the back-end currently connected to.",
    "categories": [
      "cubes",
      "import"
    ],
    "parameters": {
      "id": {
        "description": "The id of a batch job with results.",
        "schema": {
          "type": "string",
          "format": "job-id",
          "pattern": "^[A-Za-z0-9_\\-\\.~]+$"
        },
        "required": true
      }
    },
    "returns": {
      "description": "A data cube for further processing.",
      "schema": {
        "anyOf": [
          {
            "type": "object",
            "format": "raster-cube"
          },
          {
            "type": "object",
            "format": "vector-cube"
          }
        ]
      }
    }
  },
  {
    "id": "log",
    "summary": "Logarithm to a base",
    "description": "Logarithm to the base `base` of the number `x` is defined to be the inverse function of taking b to the power of x.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) so that for example `log(0, 2)` should result in infinity if the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nThe no-data value `null` is passed through and therefore gets propagated if any of the arguments is `null`.",
    "categories": [
      "math > exponential & logarithmic"
    ],
    "parameter_order": [
      "x",
      "base"
    ],
    "parameters": {
      "x": {
        "description": "A number to compute the logarithm for.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      },
      "base": {
        "description": "The numerical base.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed logarithm.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 10,
          "base": 10
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 2,
          "base": 2
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 4,
          "base": 2
        },
        "returns": 2
      },
      {
        "arguments": {
          "x": 1,
          "base": 16
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Logarithm.html",
        "title": "Logarithm explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "lt",
    "summary": "Less than comparison",
    "description": "Compares whether `x` is strictly less than `y`.\n\n**Remarks:**\n\n* If any of the operands is `null`, the return value is `null`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.\n* Comparing strings is currently not supported, but is planned to be added in the future.",
    "categories": [
      "comparison"
    ],
    "parameter_order": [
      "x",
      "y"
    ],
    "parameters": {
      "x": {
        "description": "First operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "y": {
        "description": "Second operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if `x` is strictly less than `y`, `null` if any of the operands is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 0,
          "y": 0
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 1,
          "y": 2
        },
        "returns": true
      },
      {
        "arguments": {
          "x": -0.5,
          "y": -0.6
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "00:00:00+01:00",
          "y": "00:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "1950-01-01T00:00:00Z",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2018-01-01T12:00:00+00:00",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": false
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      }
    ]
  },
  {
    "id": "lte",
    "summary": "Less than or equal to comparison",
    "description": "Compares whether `x` is less than or equal to `y`.\n\n**Remarks:**\n\n* If any of the operands is `null`, the return value is `null`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.\n* Comparing strings is currently not supported, but is planned to be added in the future.",
    "categories": [
      "comparison"
    ],
    "parameter_order": [
      "x",
      "y"
    ],
    "parameters": {
      "x": {
        "description": "First operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "y": {
        "description": "Second operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "`true` if `x` is less than or equal to `y`, `null` if any of the operands is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 0,
          "y": 0
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 1,
          "y": 2
        },
        "returns": true
      },
      {
        "arguments": {
          "x": -0.5,
          "y": -0.6
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "00:00:00+01:00",
          "y": "00:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "1950-01-01T00:00:00Z",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2018-01-01T12:00:00+00:00",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": true
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      }
    ]
  },
  {
    "id": "mask",
    "summary": "Apply a mask",
    "description": "Applies a mask to a raster data cube. A mask can either be specified as:\n\n* **Raster data cube** for which parallel pixels among `data` and `mask` are compared and those pixels in `data` are replaced, which are non-zero (for numbers) or `true` (for boolean values) in `mask`.\n* **GeoJSON or vector data cube** containing one or more polygons. All pixels for which the point at the pixel center intersects with the corresponding polygon (as defined in the Simple Features standard by the OGC) are replaced.\n\nThe pixel values are replaced with the value specified for `replacement`, which defaults to `null` (no data). No data values will be left untouched by the masking operation.",
    "categories": [
      "masks"
    ],
    "parameter_order": [
      "data",
      "mask",
      "replacement"
    ],
    "parameters": {
      "data": {
        "description": "A raster data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "mask": {
        "description": "Either a raster data cube, a GeoJSON object or a vector data cube.\n\nFor **raster data cubes**, both data cubes must be compatible so that every pixel in `data` has a parallel element in `mask`.\n\nFor **GeoJSON** the provided types can be one of the following:\n\n* A `Polygon` geometry,\n* a `GeometryCollection` containing Polygons,\n* a `Feature` with a `Polygon` geometry or\n* a `FeatureCollection` containing `Feature`s with a `Polygon` geometry.",
        "schema": {
          "anyOf": [
            {
              "type": "object",
              "format": "geojson"
            },
            {
              "type": "object",
              "format": "vector-cube"
            },
            {
              "type": "object",
              "format": "raster-cube"
            }
          ]
        },
        "required": true
      },
      "replacement": {
        "description": "The value used to replace non-zero and `true` values with.",
        "schema": {
          "type": [
            "number",
            "boolean",
            "string",
            "null"
          ],
          "default": null
        }
      }
    },
    "returns": {
      "description": "The masked raster data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "links": [
      {
        "href": "http://www.opengeospatial.org/standards/sfa",
        "rel": "about",
        "title": "Simple Features standard by the OGC"
      }
    ]
  },
  {
    "id": "max",
    "summary": "Maximum value",
    "description": "Computes the largest value of an array of numbers, which is is equal to the first element of a sorted (i.e., ordered) version the array.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The maximum value.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 3
      },
      {
        "arguments": {
          "data": [
            5,
            2.5,
            null,
            -0.7
          ]
        },
        "returns": 5
      },
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            null,
            2
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Maximum.html",
        "title": "Maximum explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "mean",
    "summary": "Arithmetic mean (average)",
    "description": "The arithmetic mean of an array of numbers is the quantity commonly called the average. It is defined as the sum of all elements divided by the number of elements.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed arithmetic mean.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 1.5
      },
      {
        "arguments": {
          "data": [
            9,
            2.5,
            null,
            -2.5
          ]
        },
        "returns": 3
      },
      {
        "arguments": {
          "data": [
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/ArithmeticMean.html",
        "title": "Arithmetic mean explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "median",
    "summary": "Statistical median",
    "description": "The statistical median of an array of numbers is the value separating the higher half from the lower half of the data.\n\n**Remarks:**\n\n* For a symmetric arrays, the result is equal to the ``mean()``.\n* The median can also be calculated by computing the quantile (see process ``quantiles()``) with the probability of *0.5*: `quantiles(data, [0.5])`.\n* An empty input array returns `null`.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed statistical median.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            3,
            3,
            6,
            7,
            8,
            9
          ]
        },
        "returns": 6
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3,
            4,
            5,
            6,
            8,
            9
          ]
        },
        "returns": 4.5
      },
      {
        "arguments": {
          "data": [
            -1,
            -0.5,
            null,
            1
          ]
        },
        "returns": -0.5
      },
      {
        "arguments": {
          "data": [
            -1,
            0,
            null,
            1
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/StatisticalMedian.html",
        "title": "Statistical Median explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "merge_cubes",
    "summary": "Merging two data cubes",
    "description": "The data cubes have to be compatible. A merge is the inverse of a split if there is no overlap. If data overlaps the parameter `overlap_resolver` must be specified to resolve the overlap. It doesn't add dimensions.",
    "categories": [
      "cubes"
    ],
    "parameter_order": [
      "cube1",
      "cube2",
      "overlap_resolver",
      "binary"
    ],
    "parameters": {
      "cube1": {
        "description": "The first data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "cube2": {
        "description": "The second data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "overlap_resolver": {
        "description": "A reducer that resolves the conflict if the data overlaps. The reducer must be a callable process (or a set of processes as process graph) such as ``mean()`` that accepts by default array as input. The process can also work on two values by setting the parameter `binary` to `true`. The reducer must return a value of the same data type as the input values in the array. `null` (default) can be specified if no overlap resolver is required.",
        "schema": {
          "anyOf": [
            {
              "title": "Unary behaviour",
              "description": "Passes an array to the reducer.",
              "type": "object",
              "format": "callback",
              "parameters": {
                "data": {
                  "description": "An array with elements of any data type.",
                  "type": "array",
                  "items": {
                    "description": "Any data type."
                  }
                }
              }
            },
            {
              "title": "Binary behaviour",
              "description": "Passes two values to the reducer.",
              "type": "object",
              "format": "callback",
              "parameters": {
                "x": {
                  "description": "The first value. Any data type could be passed."
                },
                "y": {
                  "description": "The second value. Any data type could be passed."
                }
              }
            },
            {
              "title": "No overlap resolver",
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "binary": {
        "description": "Specifies whether the process should pass two values to the reducer or a list of values (default).\n\nIf the process passes two values, the reducer must be both associative and commutative as the execution may be executed in parallel and therefore the order of execution is arbitrary.\n\nThis parameter is especially useful for UDFs passed as reducers. Back-ends may still optimize and parallelize processes that work on list of values.",
        "schema": {
          "type": "boolean",
          "default": false
        }
      }
    },
    "returns": {
      "description": "The merged data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "exceptions": {
      "OverlapResolverMissing": {
        "message": "Two data cubes with overlap but without an overlap resolver have been specified."
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Reduction_Operator",
        "title": "Background information on reduction operators (binary reducers) by Wikipedia"
      }
    ]
  },
  {
    "id": "min",
    "summary": "Minimum value",
    "description": "Computes the smallest value of an array of numbers, which is is equal to the last element of a sorted (i.e., ordered) version the array.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The minimum value.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 0
      },
      {
        "arguments": {
          "data": [
            5,
            2.5,
            null,
            -0.7
          ]
        },
        "returns": -0.7
      },
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            null,
            2
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Minimum.html",
        "title": "Minimum explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "mod",
    "summary": "Modulo",
    "description": "Remainder after division of `x` by `y`.\n\nThe result of a modulo operation has the sign of the divisor. The handling regarding the sign of the result [differs between programming languages](https://en.wikipedia.org/wiki/Modulo_operation) and needs careful consideration while implementing this process.\n\nThe no-data value `null` is passed through and therefore gets propagated if any of the arguments is `null`.",
    "categories": [
      "math"
    ],
    "parameter_order": [
      "x",
      "y"
    ],
    "parameters": {
      "x": {
        "description": "A number to be used as dividend.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      },
      "y": {
        "description": "A number to be used as divisor.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The remainder after division.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 27,
          "y": 5
        },
        "returns": 2
      },
      {
        "arguments": {
          "x": -27,
          "y": 5
        },
        "returns": 3
      },
      {
        "arguments": {
          "x": 27,
          "y": -5
        },
        "returns": -3
      },
      {
        "arguments": {
          "x": -27,
          "y": -5
        },
        "returns": -2
      },
      {
        "arguments": {
          "x": 27,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": null,
          "y": 5
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Modulo_operation",
        "title": "Modulo explained by Wikipedia"
      }
    ]
  },
  {
    "id": "multiply",
    "summary": "Multiplication of a sequence of numbers",
    "description": "Multiplies all elements in a sequential array of numbers and returns the computed product.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) whenever the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nBy default no-data values are ignored. Setting `ignore_nodata` to `false` considers no-data values so that `null` is returned if any element is such a value.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers with at least two elements.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          },
          "minItems": 2
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed product of the sequence of numbers.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "exceptions": {
      "MultiplicandMissing": {
        "message": "Multiplication requires at least two numbers."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            5,
            0
          ]
        },
        "returns": 0
      },
      {
        "arguments": {
          "data": [
            -2,
            4,
            2.5
          ]
        },
        "returns": -20
      },
      {
        "arguments": {
          "data": [
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Product.html",
        "title": "Product explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "ndvi",
    "summary": "Normalized Difference Vegetation Index",
    "description": "Computes the Normalized Difference Vegetation Index (NDVI). The NDVI is computed as *(nir - red) / (nir + red)*.\n\nThe `data` parameter expects a raster data cube with two bands that have the common names `red` and `nir` assigned. The process returns a raster data cube with two bands being replaced with a new band that holds the computed values. The newly created band is named `ndvi` by default. This name can be changed with the `name` parameter.\n\nThis process is very similar to the process ``normalized_difference()``, but determines the bands automatically based on the common name (`red`/`nir`) specified in the metadata.",
    "categories": [
      "math > indices",
      "vegetation indices"
    ],
    "parameter_order": [
      "data",
      "name"
    ],
    "parameters": {
      "data": {
        "description": "A raster data cube with two bands that have the common names `red` and `nir` assigned.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "name": {
        "description": "Name of the newly created band with the computed values. Defaults to `normalized_difference`.",
        "schema": {
          "type": "string",
          "default": "normalized_difference",
          "pattern": "^[A-Za-z0-9_]+$"
        }
      }
    },
    "returns": {
      "description": "A raster data cube with the two bands being replaced with a new band that holds the computed values.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Normalized_difference_vegetation_index",
        "title": "NDVI explained by Wikipedia"
      },
      {
        "rel": "about",
        "href": "https://earthobservatory.nasa.gov/features/MeasuringVegetation/measuring_vegetation_2.php",
        "title": "NDVI explained by NASA"
      }
    ]
  },
  {
    "id": "neq",
    "summary": "Not equal to comparison",
    "description": "Compares whether `x` is *not* strictly equal to `y`. This process is an alias for: `not(eq(val1, val2))`.\n\n**Remarks:**\n\n* Data types MUST be checked strictly, for example a string with the content *1* is not equal to the number *1*. Nevertheless, an integer *1* is equal to a floating point number *1.0* as `integer` is a sub-type of `number`.\n* If any of the operands is `null`, the return value is `null`.\n* Strings are expected to be encoded in UTF-8 by default.\n* Temporal strings MUST be compared differently than other strings and MUST NOT be compared based on their string representation due to different possible representations. For example, the UTC time zone representation `Z` has the same meaning as `+00:00`.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameter_order": [
      "x",
      "y",
      "delta",
      "case_sensitive"
    ],
    "parameters": {
      "x": {
        "description": "First operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "boolean"
            },
            {
              "type": "null"
            },
            {
              "type": "string"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "y": {
        "description": "Second operand.",
        "schema": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "boolean"
            },
            {
              "type": "null"
            },
            {
              "type": "string"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        },
        "required": true
      },
      "delta": {
        "description": "Only applicable for comparing two numbers. If this optional parameter is set to a positive non-zero number the non-equality of two numbers is checked against a delta value. This is especially useful to circumvent problems with floating point inaccuracy in machine-based computation.\n\nThis option is basically an alias for the following computation: `gt(abs(minus([x, y]), delta)`",
        "schema": {
          "type": [
            "number",
            "null"
          ],
          "default": null
        }
      },
      "case_sensitive": {
        "description": "Only applicable for comparing two strings. Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "Returns `true` if `x` is *not* equal to `y`, `null` if any of the operands is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 1,
          "y": 1
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 1,
          "y": "1"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 1.02,
          "y": 1,
          "delta": 0.01
        },
        "returns": true
      },
      {
        "arguments": {
          "x": -1,
          "y": -1.001,
          "delta": 0.01
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 115,
          "y": 110,
          "delta": 10
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "Test",
          "y": "test"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "Test",
          "y": "test",
          "case_sensitive": false
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "",
          "y": "",
          "case_sensitive": false
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "00:00:00+00:00",
          "y": "00:00:00Z"
        },
        "returns": false
      },
      {
        "description": "`y` is not a valid date-time representation and therefore will be treated as a string so that the provided values are not equal.",
        "arguments": {
          "x": "2018-01-01T12:00:00Z",
          "y": "2018-01-01T12:00:00"
        },
        "returns": true
      },
      {
        "description": "01:00 in the time zone +1 is equal to 00:00 in UTC.",
        "arguments": {
          "x": "2018-01-01T00:00:00Z",
          "y": "2018-01-01T01:00:00+01:00"
        },
        "returns": false
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      }
    ]
  },
  {
    "id": "normalized_difference",
    "summary": "Normalized difference for two bands",
    "description": "Computes the normalized difference for two bands. The normalized difference is computed as *(band1 - band2) / (band1 + band2)*.\n\nEach of the parameters expects a raster data cube with exactly one band. The process returns a raster data cube with exactly one band that holds the computed values. The newly created band is named `normalized_difference` by default. This name can be changed with the `name` parameter.\n\nThis process could be used for a number of remote sensing indices such as:\n\n* [NDVI](https://eos.com/ndvi/)\n* [NDWI](https://eos.com/ndwi/)\n* [NDSI](https://eos.com/ndsi/)\n\nPlease note that some back-ends may have native processes available for convenience such as the ``ndvi()``.",
    "categories": [
      "math > indices",
      "vegetation indices"
    ],
    "parameter_order": [
      "band1",
      "band2",
      "name"
    ],
    "parameters": {
      "band1": {
        "description": "A raster data cube with exactly one band to be used as first band.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "band2": {
        "description": "A raster data cube with exactly one band to be used as second band.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "name": {
        "description": "Name of the newly created band with the computed values. Defaults to `normalized_difference`.",
        "schema": {
          "type": "string",
          "default": "normalized_difference",
          "pattern": "^[A-Za-z0-9_]+$"
        }
      }
    },
    "returns": {
      "description": "A raster data cube with exactly one band that holds the computed values.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "links": [
      {
        "rel": "related",
        "href": "https://eos.com/ndvi/",
        "title": "NDVI explained by EOS"
      },
      {
        "rel": "related",
        "href": "https://eos.com/ndwi/",
        "title": "NDWI explained by EOS"
      },
      {
        "rel": "related",
        "href": "https://eos.com/ndsi/",
        "title": "NDSI explained by EOS"
      }
    ]
  },
  {
    "id": "not",
    "summary": "Inverting a boolean",
    "description": "Inverts a single boolean so that `true` gets `false` and `false` gets `true`.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "logic"
    ],
    "parameters": {
      "expression": {
        "description": "Boolean value to invert.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "Inverted boolean value.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "expression": null
        },
        "returns": null
      },
      {
        "arguments": {
          "expression": false
        },
        "returns": true
      },
      {
        "arguments": {
          "expression": true
        },
        "returns": false
      }
    ]
  },
  {
    "id": "or",
    "summary": "Is at least one value true?",
    "description": "Checks if **at least one** of the values is true. Evaluates each expression from the first to the last element and stops once the outcome is unambiguous.\n\nIf only one value is given the process evaluates to the given value. If no value is given (i.e. the array is empty) the process returns `null`.\n\nBy default all no-data values are ignored so that the process returns `true` if at least one of the other values is true and otherwise returns `false`.\nSetting the `ignore_nodata` flag to `false` considers no-data values so that `null` is a valid logical object. If a component is `null`, the result will be `null` if the outcome is ambiguous. See the following truth table:\n\n```\n      || null | false | true\n----- || ---- | ----- | ----\nnull  || null | null  | true\nfalse || null | false | true\ntrue  || true | true  | true\n```",
    "categories": [
      "logic",
      "reducer"
    ],
    "parameter_order": [
      "expressions",
      "ignore_nodata"
    ],
    "parameters": {
      "expressions": {
        "description": "A set of boolean values.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "boolean",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not and ignores them by default.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "Boolean result of the logical expressions.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "expressions": [
            false,
            null
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true,
            null
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            false,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "expressions": [
            true,
            null
          ],
          "ignore_nodata": false
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            true,
            false,
            true,
            false
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            true,
            false
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            false,
            false
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": []
        },
        "returns": null
      }
    ]
  },
  {
    "id": "order",
    "summary": "Create a permutation",
    "description": "Computes a permutation which allows rearranging the data into ascending or descending order. In other words, this process computes the ranked (sorted) element positions in the original list.\n\n**Remarks:**\n\n* The positions in the result are zero-based.\n* Ties will be left in their original ordering.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.",
    "categories": [
      "arrays",
      "sorting"
    ],
    "parameter_order": [
      "data",
      "asc",
      "nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array to compute the order for.",
        "schema": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "string",
                "format": "date"
              },
              {
                "type": "string",
                "format": "time"
              }
            ]
          }
        },
        "required": true
      },
      "asc": {
        "description": "The default sort order is ascending, with smallest values first. To sort in reverse (descending) order, set this parameter to `false`.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      },
      "nodata": {
        "description": "Controls the handling of no-data values (`null`). By default they are removed. If `true`, missing values in the data are put last; if `false`, they are put first.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ],
          "default": null
        }
      }
    },
    "returns": {
      "description": "The computed permutation.",
      "schema": {
        "type": "array",
        "items": {
          "type": "integer",
          "minimum": 0
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ]
        },
        "returns": [
          1,
          2,
          8,
          5,
          0,
          4,
          7,
          9,
          10
        ]
      },
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ],
          "nodata": true
        },
        "returns": [
          1,
          2,
          8,
          5,
          0,
          4,
          7,
          9,
          10,
          3,
          6
        ]
      },
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ],
          "asc": false,
          "nodata": true
        },
        "returns": [
          9,
          10,
          7,
          4,
          0,
          5,
          8,
          2,
          1,
          3,
          6
        ]
      },
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ],
          "asc": false,
          "nodata": false
        },
        "returns": [
          3,
          6,
          9,
          10,
          7,
          4,
          0,
          5,
          8,
          2,
          1
        ]
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      },
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Permutation.html",
        "title": "Permutation explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "output",
    "summary": "Send data to subscribed clients",
    "description": "Outputs the data to clients, which are subscribed to the topic `openeo.jobs.output`.",
    "categories": [
      "development"
    ],
    "experimental": true,
    "parameter_order": [
      "data",
      "id"
    ],
    "parameters": {
      "data": {
        "description": "Data to send.",
        "schema": {
          "description": "Any data type is allowed."
        },
        "required": true
      },
      "id": {
        "description": "An identifier to help identify the message in a bunch of other messages.",
        "schema": {
          "type": "string",
          "default": ""
        }
      }
    },
    "returns": {
      "description": "`false` if the information could not be sent, `true` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/apireference-subscriptions/#publish-openeojobsoutput",
        "title": "Information about the openEO API for Subscriptions"
      }
    ]
  },
  {
    "id": "pi",
    "summary": "Pi ()",
    "description": "The real number Pi () is a mathematical constant that is the ratio of the circumference of a circle to its diameter. The numerical value is approximately *3.14159*.",
    "categories": [
      "math > constants",
      "math > trigonometric"
    ],
    "parameters": {},
    "returns": {
      "description": "The numerical value of Pi.",
      "schema": {
        "type": "number"
      }
    },
    "examples": [
      {
        "title": "Test for sin() = 0",
        "process_graph": {
          "pi1": {
            "process_id": "pi",
            "arguments": {}
          },
          "sin1": {
            "process_id": "sin",
            "arguments": {
              "data": {
                "from_node": "pi1"
              }
            },
            "result": true
          }
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Pi.html",
        "title": "Mathematical constant Pi explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "power",
    "summary": "Exponentiation",
    "description": "Computes the exponentiation for the base `base` raised to the power of `p`.\n\nThe no-data value `null` is passed through and therefore gets propagated if any of the arguments is `null`.",
    "categories": [
      "math",
      "math > exponential & logarithmic"
    ],
    "parameter_order": [
      "base",
      "p"
    ],
    "parameters": {
      "base": {
        "description": "The numerical base.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      },
      "p": {
        "description": "The numerical exponent.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed value for `base` raised to the power of `p`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "base": 0,
          "p": 2
        },
        "returns": 0
      },
      {
        "arguments": {
          "base": 2.5,
          "p": 0
        },
        "returns": 1
      },
      {
        "arguments": {
          "base": 3,
          "p": 3
        },
        "returns": 27
      },
      {
        "arguments": {
          "base": 5,
          "p": -1
        },
        "returns": 0.2
      },
      {
        "arguments": {
          "base": 1,
          "p": 0.5
        },
        "returns": 1
      },
      {
        "arguments": {
          "base": 1,
          "p": null
        },
        "returns": null
      },
      {
        "arguments": {
          "base": null,
          "p": 2
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Power.html",
        "title": "Power explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "product",
    "summary": "Multiplication of a sequence of numbers",
    "description": "This process is an exact alias for the `multiply` process. See ``multiply()`` for more information.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "See ``multiply()`` for more information.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "See ``multiply()`` for more information.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "See ``multiply()`` for more information.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "exceptions": {
      "MultiplicandMissing": {
        "message": "Multiplication requires at least two numbers."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            5,
            0
          ]
        },
        "returns": 0
      },
      {
        "arguments": {
          "data": [
            -2,
            4,
            2.5
          ]
        },
        "returns": -20
      },
      {
        "arguments": {
          "data": [
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      }
    ]
  },
  {
    "id": "property",
    "summary": "Get metadata for data cubes or collections",
    "description": "Retrieves metadata properties for a data cube (if a `raster-cube` or `vector-cube` is passed) or a collection (if a collection id is passed). Properties for a single dimension can be queried with the `dimension` parameter.\n\nAvailable metadata properties can be retrieved with the openEO Data Discovery for Collections, but for data cubes only a subset may be available after processing.",
    "categories": [
      "cubes"
    ],
    "parameter_order": [
      "data",
      "name",
      "dimension"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "anyOf": [
            {
              "type": "object",
              "format": "raster-cube"
            },
            {
              "type": "object",
              "format": "vector-cube"
            },
            {
              "description": "A collection id.",
              "type": "string",
              "format": "collection-id",
              "pattern": "^[A-Za-z0-9_\\-\\.~/]+$"
            }
          ]
        },
        "required": true
      },
      "name": {
        "description": "Name of the metadata property.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "dimension": {
        "description": "Optionally, a dimension to get the property for. `null` by default, which gets a property globally for the collection/data cube. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.",
        "schema": {
          "type": [
            "string",
            "null"
          ],
          "default": null
        }
      }
    },
    "returns": {
      "description": "The value for the metadata property or `null` if no information are available.",
      "schema": {
        "description": "Any data type is allowed."
      }
    },
    "exceptions": {
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      }
    }
  },
  {
    "id": "quantiles",
    "summary": "Quantiles",
    "description": "Calculates quantiles, which are cut points dividing the range of a probability distribution into either\n\n* intervals corresponding to the given `probabilities` or\n* (nearly) equal-sized intervals (q-quantiles based on the parameter `q`).\n\nEither the parameter `probabilites` or `q` must be specified, otherwise the `QuantilesParameterMissing` exception must be thrown. If both parameters are set the `QuantilesParameterConflict` exception must be thrown.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "probabilities",
      "q",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "probabilities": {
        "description": "A list of probabilities to calculate quantiles for. The probabilities must be between 0 and 1.",
        "schema": {
          "type": "array",
          "items": {
            "type": "number",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "q": {
        "description": "A number of intervals to calculate quantiles for. Calculates q-quantiles with (nearly) equal-sized intervals.",
        "schema": {
          "type": "integer",
          "minimum": 2
        }
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that an array with `null` values is returned if any element is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "An array with the computed quantiles. The list has either\n\n* as many elements as the given list of `probabilities` had or\n* *`q`-1* elements.\n\nIf the input array is empty the resulting array is filled with as many `null` values as required according to the list above. For an example, see the 'Empty array example'.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "exceptions": {
      "QuantilesParameterMissing": {
        "message": "The process 'quantiles' requires either the 'probabilities' or 'q' parameter to be set."
      },
      "QuantilesParameterConflict": {
        "message": "The process 'quantiles' only allows that either the 'probabilities' or the 'q' parameter is set."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            2,
            4,
            4,
            4,
            5,
            5,
            7,
            9
          ],
          "probabilities": [
            0.005,
            0.01,
            0.02,
            0.05,
            0.1,
            0.5
          ]
        },
        "returns": [
          2.07,
          2.14,
          2.28,
          2.7,
          3.4,
          4.5
        ]
      },
      {
        "arguments": {
          "data": [
            2,
            4,
            4,
            4,
            5,
            5,
            7,
            9
          ],
          "q": 4
        },
        "returns": [
          4,
          4.5,
          5.5
        ]
      },
      {
        "arguments": {
          "data": [
            -1,
            -0.5,
            null,
            1
          ],
          "q": 2
        },
        "returns": [
          -0.5
        ]
      },
      {
        "arguments": {
          "data": [
            -1,
            -0.5,
            null,
            1
          ],
          "q": 4,
          "ignore_nodata": false
        },
        "returns": [
          null,
          null,
          null
        ]
      },
      {
        "title": "Empty array example",
        "arguments": {
          "data": [],
          "probabilities": [
            0.1,
            0.5
          ]
        },
        "returns": [
          null,
          null
        ]
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Quantile",
        "title": "Quantiles explained by Wikipedia"
      }
    ]
  },
  {
    "id": "rearrange",
    "summary": "Rearranges an array based on a permutation",
    "description": "Rearranges an array based on a permutation.",
    "categories": [
      "arrays",
      "sorting"
    ],
    "parameter_order": [
      "data",
      "order"
    ],
    "parameters": {
      "data": {
        "description": "An array to rearrange.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        },
        "required": true
      },
      "order": {
        "description": "A permutation used for rearranging, i.e. a ranked list of element positions in the original list. The positions must be zero-based.",
        "schema": {
          "type": "array",
          "items": {
            "type": "integer",
            "minimum": 0
          }
        },
        "required": true
      }
    },
    "returns": {
      "description": "The rearranged array.",
      "schema": {
        "type": "array",
        "items": {
          "description": "Any data type is allowed."
        }
      }
    },
    "examples": [
      {
        "title": "Reverse a list",
        "arguments": {
          "data": [
            5,
            4,
            3
          ],
          "order": [
            2,
            1,
            0
          ]
        },
        "returns": [
          3,
          4,
          5
        ]
      },
      {
        "title": "Remove two elements",
        "arguments": {
          "data": [
            5,
            4,
            3,
            2
          ],
          "order": [
            1,
            3
          ]
        },
        "returns": [
          4,
          2
        ]
      },
      {
        "title": "Swap two elements",
        "arguments": {
          "data": [
            5,
            4,
            3,
            2
          ],
          "order": [
            0,
            2,
            1,
            3
          ]
        },
        "returns": [
          5,
          3,
          4,
          2
        ]
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Permutation.html",
        "title": "Permutation explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "reduce",
    "summary": "Reduce dimensions",
    "description": "Applies a reducer to a data cube dimension by collapsing all the input values along the specified dimension into an output value computed by the reducer.\n\nThe reducer must be a callable process (or a set of processes as process graph) that accepts by default array as input. The process can also work on two values by setting the parameter `binary` to `true`. The reducer must compute a single or multiple return values of the same type as the input values were. Multiple values must be wrapped in an array. An example for a process returning a single value is ``median()``. In this case the specified dimension would be removed. If a callback such as ``extrema()`` returns multiple values, a new dimension with the specified name in `target_dimension` is created (see the description of the parameter for more information).\n\nA special case is that the reducer can be set to `null`, which is the default if no reducer is specified. It acts as a no-operation reducer so that the remaining value is treated like a reduction result and the dimension gets dropped. This only works on dimensions with a single dimension value left (e.g. after filtering for a single band), otherwise the process fails with a `TooManyDimensionValues` error.\n\nNominal values can be reduced too, but need to be mapped. For example date strings to numeric timestamps since 1970 etc.",
    "categories": [
      "cubes",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "reducer",
      "dimension",
      "target_dimension",
      "binary"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "reducer": {
        "description": "A reducer to be applied on the specified dimension (see the process description for more details).",
        "schema": {
          "anyOf": [
            {
              "title": "Unary behaviour",
              "description": "Passes an array to the reducer.",
              "type": "object",
              "format": "callback",
              "parameters": {
                "data": {
                  "description": "An array with elements of any data type.",
                  "type": "array",
                  "items": {
                    "description": "Any data type."
                  }
                }
              }
            },
            {
              "title": "Binary behaviour",
              "description": "Passes two values to the reducer.",
              "type": "object",
              "format": "callback",
              "parameters": {
                "x": {
                  "description": "The first value. Any data type could be passed."
                },
                "y": {
                  "description": "The second value. Any data type could be passed."
                }
              }
            },
            {
              "title": "No operation behaviour",
              "description": "Specifying `null` works only on dimensions with a single dimension value left. In this case the remaining value is treated like a reduction result and the dimension gets dropped.",
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "dimension": {
        "description": "The dimension over which to reduce. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Remarks:**\n\n* The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.\n* There could be multiple spatial dimensions such as `x`, `y` or `z`.\n* For multi-spectral imagery there is usually a separate dimension of type `bands` for the bands.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "target_dimension": {
        "description": "The name of the target dimension. Only required if the reducer returns multiple values, otherwise ignored. By default creates a new dimension with the specified name and the type `other` (see ``add_dimension()``). If a dimension with the specified name exists, the dimension is replaced, but keeps the original type.",
        "schema": {
          "type": [
            "string",
            "null"
          ],
          "default": null
        }
      },
      "binary": {
        "description": "Specifies whether the process should pass two values to the reducer or a list of values (default).\n\nIf the process passes two values, the reducer must be both associative and commutative as the execution may be executed in parallel and therefore the order of execution is arbitrary.\n\nThis parameter is especially useful for UDFs passed as reducers. Back-ends may still optimize and parallelize processes that work on list of values.\n\nThis parameter can't be used with the reducer set to `null`. If a reducer is specified but only a single value is available, the reducer doesn't get executed.",
        "schema": {
          "type": "boolean",
          "default": false
        }
      }
    },
    "returns": {
      "description": "A data cube with the newly computed values. The number of dimensions is reduced for callbacks returning a single value or doesn't change if the callback returns multiple values. The resolution and cardinality are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "exceptions": {
      "TooManyDimensionValues": {
        "message": "The number of dimension values exceeds one, which requires a reducer."
      },
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Reduction_Operator",
        "title": "Background information on reduction operators (binary reducers) by Wikipedia"
      }
    ]
  },
  {
    "id": "rename_dimension",
    "summary": "Renames a dimension",
    "description": "Renames a dimension in the data cube. Afterwards, the dimension can be referenced with the new name.",
    "categories": [
      "cubes"
    ],
    "parameter_order": [
      "data",
      "old",
      "new"
    ],
    "parameters": {
      "data": {
        "description": "The data cube.",
        "schema": {
          "anyOf": [
            {
              "type": "object",
              "format": "raster-cube"
            },
            {
              "type": "object",
              "format": "vector-cube"
            }
          ]
        },
        "required": true
      },
      "old": {
        "description": "The current name of the dimension. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "new": {
        "description": "A new Name for the dimension. Fails with a `DimensionExists` error if a dimension with the specified name exists.",
        "schema": {
          "type": "string"
        },
        "required": true
      }
    },
    "returns": {
      "description": "The data cube with the renamed dimension. The old name can not be referenced any longer.",
      "schema": {
        "anyOf": [
          {
            "type": "object",
            "format": "raster-cube"
          },
          {
            "type": "object",
            "format": "vector-cube"
          }
        ]
      }
    },
    "exceptions": {
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      },
      "DimensionExists": {
        "message": "A dimension with the specified name already exists."
      }
    }
  },
  {
    "id": "resample_cube_spatial",
    "summary": "Resample the spatial dimensions to a target data cube",
    "description": "Resamples the spatial dimensions (x,y) from a source data cube to a target data cube and return the results as a new data cube.",
    "categories": [
      "cubes",
      "aggregate & resample"
    ],
    "parameter_order": [
      "data",
      "target",
      "method"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "target": {
        "description": "A data cube that describes the spatial target resolution.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "method": {
        "description": "Resampling method. Methods are inspired by GDAL, see [gdalwarp](https://www.gdal.org/gdalwarp.html) for more information.",
        "schema": {
          "type": "string",
          "default": "near",
          "enum": [
            "near",
            "bilinear",
            "cubic",
            "cubicspline",
            "lanczos",
            "average",
            "mode",
            "max",
            "min",
            "med",
            "q1",
            "q3"
          ]
        }
      }
    },
    "returns": {
      "description": "A data cube with potentially lower spatial resolution and potentially lower cardinality, but the same number of dimensions as the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "links": [
      {
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/glossary/#aggregation-and-resampling",
        "rel": "about",
        "title": "Resampling explained in the openEO glossary"
      }
    ]
  },
  {
    "id": "resample_cube_temporal",
    "summary": "Resample a temporal dimension to a target data cube",
    "description": "Resamples a temporal dimension from a source data cube to a target data cube and return the results as a new data cube.\n\nIf the dimension is not set or is set to `null`, the data cube is expected to only have one temporal dimension.",
    "categories": [
      "cubes",
      "aggregate & resample"
    ],
    "parameter_order": [
      "data",
      "target",
      "method",
      "dimension",
      "binary"
    ],
    "parameters": {
      "data": {
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "target": {
        "description": "A data cube that describes the temporal target resolution.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "method": {
        "description": "A resampling method to be applied, could be a reducer for downsampling or other methods for upsampling. The reducer must be a callable process (or a set of processes as process graph) such as ``mean()`` that accepts by default array as input. The process can also work on two values by setting the parameter `binary` to `true`.",
        "schema": {
          "anyOf": [
            {
              "title": "Unary behaviour",
              "description": "Passes an array to the reducer.",
              "type": "object",
              "format": "callback",
              "parameters": {
                "data": {
                  "description": "An array with elements of any data type.",
                  "type": "array",
                  "items": {
                    "description": "Any data type."
                  }
                }
              }
            },
            {
              "title": "Binary behaviour",
              "description": "Passes two values to the reducer.",
              "type": "object",
              "format": "callback",
              "parameters": {
                "x": {
                  "description": "The first value. Any data type could be passed."
                },
                "y": {
                  "description": "The second value. Any data type could be passed."
                }
              }
            }
          ]
        },
        "required": true
      },
      "dimension": {
        "description": "The temporal dimension to resample, which must exist with this name in both data cubes. If the dimension is not set or is set to `null`, the data cube is expected to only have one temporal dimension. Fails with a `TooManyDimensions` error if it has more dimensions. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Note:** The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.",
        "schema": {
          "type": [
            "string",
            "null"
          ],
          "default": null
        }
      },
      "binary": {
        "description": "Specifies whether the process should pass two values to the reducer specified as resampling method or a list of values (default).\n\nIf the process passes two values, the reducer must be both associative and commutative as the execution may be executed in parallel and therefore the order of execution is arbitrary.\n\nThis parameter is especially useful for UDFs passed as reducers. Back-ends may still optimize and parallelize processes that work on list of values.",
        "schema": {
          "type": "boolean",
          "default": false
        }
      }
    },
    "returns": {
      "description": "A data cube with potentially lower temporal resolution and potentially lower cardinality, but the same number of dimensions as the original data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "exceptions": {
      "TooManyDimensions": {
        "message": "The number of temporal dimensions must be reduced to one for 'resample_cube_temporal'."
      },
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/processes/#openeo-specific-formats",
        "title": "Information about the supported temporal formats."
      },
      {
        "href": "https://open-eo.github.io/openeo-api/v/0.4.1/glossary/#aggregation-and-resampling",
        "rel": "about",
        "title": "Resampling explained in the openEO glossary"
      },
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Reduction_Operator",
        "title": "Background information on reduction operators (binary reducers) by Wikipedia"
      }
    ]
  },
  {
    "id": "resample_spatial",
    "summary": "Resample and warp the spatial dimensions",
    "description": "Resamples the spatial dimensions (x,y) of the data cube to a specified resolution and/or warps the data cube to the target projection. At least `resolution` or `projection` must be specified.\n\nUse ``filter_bbox()`` to set the target spatial extent.",
    "categories": [
      "cubes",
      "aggregate & resample"
    ],
    "parameter_order": [
      "data",
      "resolution",
      "projection",
      "method",
      "align"
    ],
    "parameters": {
      "data": {
        "description": "A raster data cube.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      },
      "resolution": {
        "description": "Resamples the data cube to the target resolution, which can be specified either as separate values for x and y or as a single value for both axes. Specified in the units of the target projection. Doesn't change the resolution by default (`0`).",
        "schema": {
          "anyOf": [
            {
              "description": "A single number used as resolution for both x and y.",
              "type": "number",
              "minimum": 0
            },
            {
              "description": "A two-element array to specify separate resolutions for x (first element) and y (second element).",
              "type": "array",
              "minItems": 2,
              "maxItems": 2,
              "items": {
                "type": "number",
                "minimum": 0
              }
            }
          ],
          "default": 0
        }
      },
      "projection": {
        "description": "Warps the data cube to the target projection. Target projection specified as [EPSG](http://www.epsg.org) code or [PROJ](https://proj4.org) definition. Doesn't change the projection by default (`null`).",
        "schema": {
          "anyOf": [
            {
              "title": "EPSG Code",
              "type": "integer",
              "format": "epsg-code",
              "examples": [
                7099
              ]
            },
            {
              "title": "PROJ definition",
              "type": "string",
              "format": "proj-definition",
              "examples": [
                "+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
              ]
            },
            {
              "title": "Don't change projection",
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "method": {
        "description": "Resampling method. Methods are inspired by GDAL, see [gdalwarp](https://www.gdal.org/gdalwarp.html) for more information.",
        "schema": {
          "type": "string",
          "default": "near",
          "enum": [
            "near",
            "bilinear",
            "cubic",
            "cubicspline",
            "lanczos",
            "average",
            "mode",
            "max",
            "min",
            "med",
            "q1",
            "q3"
          ]
        }
      },
      "align": {
        "description": "Specifies to which corner of the spatial extent the new resampled data is aligned to.",
        "schema": {
          "type": "string",
          "enum": [
            "lower-left",
            "upper-left",
            "lower-right",
            "upper-right"
          ],
          "default": "lower-left"
        }
      }
    },
    "returns": {
      "description": "A raster data cube with values warped onto the new projection.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://proj4.org/usage/projections.html",
        "title": "PROJ parameters for cartographic projections"
      },
      {
        "rel": "about",
        "href": "http://www.epsg-registry.org",
        "title": "Official EPSG code registry"
      },
      {
        "rel": "about",
        "href": "http://www.epsg.io",
        "title": "Unofficial EPSG code database"
      }
    ]
  },
  {
    "id": "round",
    "summary": "Rounds to a specified precision",
    "description": "Rounds a real number `x` to specified precision `p`.\n\nIf the fractional part of `x` is halfway between two integers, one of which is even and the other odd, then the even number is returned.\nThis behaviour follows [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935). This kind of rounding is also called \"rounding to nearest\" or \"banker's rounding\". It minimizes rounding errors that result from consistently rounding a midpoint value in a single direction.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > rounding"
    ],
    "parameter_order": [
      "x",
      "p"
    ],
    "parameters": {
      "x": {
        "description": "A number to round.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      },
      "p": {
        "description": "A positive number specifies the number of digits after the decimal point to round to. A negative number means rounding to a power of ten, so for example *-2* rounds to the nearest hundred. Defaults to *0*.",
        "schema": {
          "type": "integer",
          "default": 0
        }
      }
    },
    "returns": {
      "description": "The rounded number.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.56,
          "p": 1
        },
        "returns": 3.6
      },
      {
        "arguments": {
          "x": -0.4444444,
          "p": 2
        },
        "returns": -0.44
      },
      {
        "arguments": {
          "x": -2.5
        },
        "returns": -2
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": -4
      },
      {
        "arguments": {
          "x": 1234.5,
          "p": -2
        },
        "returns": 1200
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/AbsoluteValue.html",
        "title": "Absolute value explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "run_process_graph",
    "summary": "Load and run a stored process graph",
    "description": "Loads and executes a stored process graph.\n\nThe process can either load\n\n* a locally stored process graph by id, which is stored by the authenticated user on the back-end currently connected to or\n* a remotely stored and published process graph by absolute URI, for example from [openEO Hub](https://hub.openeo.org).",
    "categories": [
      "import"
    ],
    "experimental": true,
    "parameter_order": [
      "id",
      "variables"
    ],
    "parameters": {
      "id": {
        "description": "A process graph id or an absolute URI to an externally hosted process graph.",
        "schema": {
          "anyOf": [
            {
              "description": "URI",
              "type": "string",
              "format": "uri"
            },
            {
              "description": "Process graph id",
              "type": "string",
              "format": "process-graph-id",
              "pattern": "^[A-Za-z0-9_\\-\\.~]+$"
            }
          ]
        },
        "required": true
      },
      "variables": {
        "description": "Key-value-pairs with values for variables that are defined by the process graph. The key of the pair has to be the corresponding `variable_id` for the value specified. The replacement for the variable is the value of the pair.",
        "schema": {
          "type": "object",
          "format": "process-graph-variables",
          "default": {}
        }
      }
    },
    "returns": {
      "description": "The result of processing the process graph.",
      "schema": {
        "description": "Any data type."
      }
    },
    "links": [
      {
        "href": "https://github.com/Open-EO/openeo-processes/issues/5",
        "rel": "experimental",
        "title": "More information about the experimental status of the process"
      }
    ]
  },
  {
    "id": "run_udf_externally",
    "summary": "Run an externally hosted UDF container",
    "description": "Runs a compatible UDF container that is either externally hosted by a service provider or running on a local machine of the user. The UDF container must follow the [openEO UDF specification](https://open-eo.github.io/openeo-udf/).\n\nThe referenced UDF service can be executed as callback in several processes such as ``aggregate_temporal()``, ``apply()``, ``apply_dimension()``, ``filter()`` and ``reduce()``. In this case an array is passed instead of a raster data cube. The user must ensure that the data is properly passed as an array so that the UDF can make sense of it.",
    "categories": [
      "import",
      "udf"
    ],
    "parameter_order": [
      "data",
      "url",
      "context"
    ],
    "parameters": {
      "data": {
        "description": "The data to be passed to the UDF as array or raster data cube.",
        "schema": {
          "anyOf": [
            {
              "title": "Raster data cube",
              "type": "object",
              "format": "raster-cube"
            },
            {
              "title": "Array",
              "type": "array",
              "minItems": 1,
              "items": {
                "description": "Any data type."
              }
            }
          ]
        },
        "required": true
      },
      "url": {
        "description": "URL to a remote UDF service.",
        "schema": {
          "type": "string",
          "format": "uri"
        },
        "required": true
      },
      "context": {
        "description": "Additional data such as configuration options that should be passed to the UDF.",
        "schema": {
          "type": "object",
          "default": {}
        }
      }
    },
    "returns": {
      "description": "The data processed by the UDF service. Returns a raster data cube if a raster data cube was passed for `data`. If an array was passed for `data`, the returned value is defined by the context and is exactly what the UDF returned.",
      "schema": {
        "anyOf": [
          {
            "title": "Raster data cube",
            "type": "object",
            "format": "raster-cube"
          },
          {
            "title": "Any",
            "description": "Any data type."
          }
        ]
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-udf/",
        "title": "openEO UDF specification"
      },
      {
        "rel": "about",
        "href": "https://github.com/Open-EO/openeo-udf",
        "title": "openEO UDF repository"
      }
    ]
  },
  {
    "id": "run_udf",
    "summary": "Run an UDF",
    "description": "Runs an UDF in one of the supported runtime environments.\n\nThe process can either:\n\n1. load and run a locally stored UDF from a file in the workspace of the authenticated user. The path to the UDF file must be relative to the root directory of the user's workspace, so without the user id in the path.\n2. fetch and run a remotely stored and published UDF by absolute URI, for example from [openEO Hub](https://hub.openeo.org)).\n3. run the source code specified inline as string.\n\nThe loaded UDF can be executed as callback in several processes such as ``aggregate_temporal()``, ``apply()``, ``apply_dimension()``, ``filter()`` and ``reduce()``. In this case an array is passed instead of a raster data cube. The user must ensure that the data is properly passed as an array so that the UDF can make sense of it.",
    "categories": [
      "import",
      "udf"
    ],
    "parameter_order": [
      "data",
      "udf",
      "runtime",
      "version",
      "context"
    ],
    "parameters": {
      "data": {
        "description": "The data to be passed to the UDF as array or raster data cube.",
        "schema": {
          "anyOf": [
            {
              "title": "Raster data cube",
              "type": "object",
              "format": "raster-cube"
            },
            {
              "title": "Array",
              "type": "array",
              "minItems": 1,
              "items": {
                "description": "Any data type."
              }
            }
          ]
        },
        "required": true
      },
      "udf": {
        "description": "Either source code, an absolute URL or a path to an UDF script.",
        "schema": {
          "anyOf": [
            {
              "description": "URI to an UDF",
              "type": "string",
              "format": "uri"
            },
            {
              "description": "Source code as string",
              "type": "string"
            }
          ]
        },
        "required": true
      },
      "runtime": {
        "description": "An UDF runtime identifier available at the back-end.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "version": {
        "description": "An UDF runtime version. If set to `null`, the default runtime version specified for each runtime is used.",
        "schema": {
          "type": [
            "string",
            "null"
          ],
          "default": null
        }
      },
      "context": {
        "description": "Additional data such as configuration options that should be passed to the UDF.",
        "schema": {
          "type": "object",
          "default": {}
        }
      }
    },
    "exceptions": {
      "InvalidVersion": {
        "message": "The specified UDF runtime version is not supported."
      }
    },
    "returns": {
      "description": "The data processed by the UDF. Returns a raster data cube if a raster data cube was passed for `data`. If an array was passed for `data`, the returned value is defined by the context and is exactly what the UDF returned.",
      "schema": {
        "anyOf": [
          {
            "title": "Raster data cube",
            "type": "object",
            "format": "raster-cube"
          },
          {
            "title": "Any",
            "description": "Any data type."
          }
        ]
      }
    }
  },
  {
    "id": "save_result",
    "summary": "Save processed data to storage",
    "description": "Saves processed data to the local user workspace / data store of the authenticated user. This process aims to be compatible to GDAL/OGR formats and options. STAC-compatible metadata should be stored with the processed data.\n\nCalling this process may be rejected by back-ends in the context of secondary web services.",
    "categories": [
      "cubes",
      "export"
    ],
    "parameter_order": [
      "data",
      "format",
      "options"
    ],
    "parameters": {
      "data": {
        "description": "The data to save.",
        "schema": {
          "anyOf": [
            {
              "type": "object",
              "format": "raster-cube"
            },
            {
              "type": "object",
              "format": "vector-cube"
            }
          ]
        },
        "required": true
      },
      "format": {
        "description": "The file format to save to. It must be one of the values that the server reports as supported output formats, which usually correspond to the short GDAL/OGR codes. This parameter is *case insensitive*.",
        "schema": {
          "type": "string",
          "format": "output-format"
        },
        "required": true
      },
      "options": {
        "description": "The file format options to be used to create the file(s). Must correspond to the options that the server reports as supported options for the chosen `format`. The option names and valid values usually correspond to the GDAL/OGR format options.",
        "schema": {
          "type": "object",
          "format": "output-format-options",
          "default": {}
        }
      }
    },
    "returns": {
      "description": "`false` if saving failed, `true` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://www.gdal.org/formats_list.html",
        "title": "GDAL Raster Formats"
      },
      {
        "rel": "about",
        "href": "https://www.gdal.org/ogr_formats.html",
        "title": "OGR Vector Formats"
      }
    ]
  },
  {
    "id": "sd",
    "summary": "Standard deviation",
    "description": "Computes the sample standard deviation, which quantifies the amount of variation of an array of numbers. It is defined to be the square root of the corresponding variance (see ``variance()``).\n\nA low standard deviation indicates that the values tend to be close to the expected value, while a high standard deviation indicates that the values are spread out over a wider range.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed sample standard deviation.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            -1,
            1,
            3,
            null
          ]
        },
        "returns": 2
      },
      {
        "arguments": {
          "data": [
            -1,
            1,
            3,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/StandardDeviation.html",
        "title": "Standard deviation explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "sgn",
    "summary": "Signum",
    "description": "The signum (also known as *sign*) of `x` is defined as:\n\n* *1* if *x > 0*\n* *0* if *x = 0*\n* *-1* if *x < 0*\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed signum value of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": -2
        },
        "returns": -1
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": null
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Sign.html",
        "title": "Sign explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "sin",
    "summary": "Sine",
    "description": "Computes the sine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed sine of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Sine.html",
        "title": "Sine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "sinh",
    "summary": "Hyperbolic sine",
    "description": "Computes the hyperbolic sine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed hyperbolic sine of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/HyperbolicSine.html",
        "title": "Hyperbolic sine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "sort",
    "summary": "Sort data",
    "description": "Sorts an array into ascending (default) or descending order.\n\nThis process is an alias to call ``order()`` and ``rearrange()`` consecutively: `rearrange(data, order(data, nodata))`. This process could be faster though. See ``order()`` for more information on sorting behaviour.",
    "categories": [
      "arrays",
      "sorting"
    ],
    "parameter_order": [
      "data",
      "asc",
      "nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array with data to sort.",
        "schema": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "string",
                "format": "date"
              },
              {
                "type": "string",
                "format": "time"
              }
            ]
          }
        },
        "required": true
      },
      "asc": {
        "description": "The default sort order is ascending, with smallest values first. To sort in reverse (descending) order, set this parameter to `false`.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      },
      "nodata": {
        "description": "Controls the handling of no-data values (`null`). By default they are removed. If `true`, missing values in the data are put last; if `false`, they are put first.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ],
          "default": null
        }
      }
    },
    "returns": {
      "description": "The sorted array.",
      "schema": {
        "type": "array",
        "items": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "type": "string",
              "format": "date"
            },
            {
              "type": "string",
              "format": "time"
            }
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ]
        },
        "returns": [
          -1,
          2,
          3,
          4,
          6,
          7,
          8,
          9,
          9
        ]
      },
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ],
          "asc": false,
          "nodata": true
        },
        "returns": [
          9,
          9,
          8,
          7,
          6,
          4,
          3,
          2,
          -1,
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "sqrt",
    "summary": "Square root",
    "description": "Computes the square root of a real number `x`. This process is an alias for `x` to the power of *0.5*: `power(x, 0.5)`.\n\nA square root of x is a number a such that *a^2^ = x*. Therefore, the square root is the inverse function of a to the power of 2, but only for *a >= 0*.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math",
      "math > exponential & logarithmic"
    ],
    "parameters": {
      "x": {
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed square root.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 1
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 9
        },
        "returns": 3
      },
      {
        "arguments": {
          "x": null
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/SquareRoot.html",
        "title": "Square root explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "subtract",
    "summary": "Subtraction of a sequence of numbers",
    "description": "Takes the first element of a sequential array of numbers and subtracts all other elements from it.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) whenever the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nBy default no-data values are ignored. Setting `ignore_nodata` to `false` considers no-data values so that `null` is returned if any element is such a value.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers with at least two elements.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          },
          "minItems": 2
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed result of the sequence of numbers.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "exceptions": {
      "SubtrahendMissing": {
        "message": "Subtraction requires at least two numbers (a minuend and one or more subtrahends)."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            5,
            10
          ]
        },
        "returns": -5
      },
      {
        "arguments": {
          "data": [
            -2,
            4,
            -2
          ]
        },
        "returns": -4
      },
      {
        "arguments": {
          "data": [
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Subtraction.html",
        "title": "Subtraction explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "sum",
    "summary": "Addition of a sequence of numbers",
    "description": "Sums up all elements in a sequential array of numbers and returns the computed sum.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) whenever the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nBy default no-data values are ignored. Setting `ignore_nodata` to `false` considers no-data values so that `null` is returned if any element is such a value.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers with at least two elements.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          },
          "minItems": 2
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed sum of the sequence of numbers.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "exceptions": {
      "SummandMissing": {
        "message": "Addition requires at least two numbers."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            5,
            1
          ]
        },
        "returns": 6
      },
      {
        "arguments": {
          "data": [
            -2,
            4,
            2.5
          ]
        },
        "returns": 4.5
      },
      {
        "arguments": {
          "data": [
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Sum.html",
        "title": "Sum explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "tan",
    "summary": "Tangent",
    "description": "Computes the tangent of `x`. The tangent is defined to be the sine of x divided by the cosine of x.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed tangent of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Tangent.html",
        "title": "Tangent explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "tanh",
    "summary": "Hyperbolic tangent",
    "description": "Computes the hyperbolic tangent of `x`. The tangent is defined to be the hyperbolic sine of x divided by the hyperbolic cosine of x.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": {
      "x": {
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "required": true
      }
    },
    "returns": {
      "description": "The computed hyperbolic tangent of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/HyperbolicTangent.html",
        "title": "Hyperbolic tangent explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "text_begins",
    "summary": "Text begins with another text",
    "description": "Checks whether the text (also known as *string*) specified for `data` contains the text specified for `pattern` at the very beginning. Both are expected to be encoded in UTF-8 by default. Regular expressions are not supported.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameter_order": [
      "data",
      "pattern",
      "case_sensitive"
    ],
    "parameters": {
      "data": {
        "description": "Text in which to find something at the beginning.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "pattern": {
        "description": "Text to find at the beginning of `data`.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "case_sensitive": {
        "description": "Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "`true` if `data` begins with `pattern`, false` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "amet"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "Lorem"
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "lorem"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "lorem",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "",
          "pattern": "",
          "case_sensitive": false
        },
        "returns": true
      }
    ]
  },
  {
    "id": "text_contains",
    "summary": "Text contains another text",
    "description": "Checks whether the text (also known as *string*) specified for `data` contains the text specified for `pattern`. Both are expected to be encoded in UTF-8 by default. Regular expressions are not supported.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameter_order": [
      "data",
      "pattern",
      "case_sensitive"
    ],
    "parameters": {
      "data": {
        "description": "Text in which to find something in.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "pattern": {
        "description": "Text to find in `data`.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "case_sensitive": {
        "description": "Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "`true` if `data` contains the `pattern`, false` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "openEO"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "ipsum dolor"
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "Ipsum Dolor"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "SIT",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "",
          "pattern": "",
          "case_sensitive": false
        },
        "returns": true
      }
    ]
  },
  {
    "id": "text_ends",
    "summary": "Text ends with another text",
    "description": "Checks whether the text (also known as *string*) specified for `data` contains the text specified for `pattern` at the very end. Both are expected to be encoded in UTF-8 by default. Regular expressions are not supported.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameter_order": [
      "data",
      "pattern",
      "case_sensitive"
    ],
    "parameters": {
      "data": {
        "description": "Text in which to find something at the end.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "pattern": {
        "description": "Text to find at the end of `data`.",
        "schema": {
          "type": "string"
        },
        "required": true
      },
      "case_sensitive": {
        "description": "Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "`true` if `data` ends with `pattern`, false` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "amet"
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "AMET"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "Lorem"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "AMET",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "",
          "pattern": "",
          "case_sensitive": false
        },
        "returns": true
      }
    ]
  },
  {
    "id": "text_merge",
    "summary": "Concatenate elements to a string",
    "description": "Merges string representations of a set of elements together to a single string, with the separator between each element.",
    "categories": [
      "texts"
    ],
    "parameter_order": [
      "data",
      "separator"
    ],
    "parameters": {
      "data": {
        "description": "A set of elements. Numbers, boolean values and null values get converted to their (lower case) string representation. For example: `1` (integer), `-1.5` (number), `true` / `false` (boolean values)",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "string",
              "number",
              "boolean",
              "null"
            ]
          }
        },
        "required": true
      },
      "separator": {
        "description": "A separator to put between each of the individual texts. Defaults to an empty string.",
        "schema": {
          "type": [
            "string",
            "number",
            "boolean",
            "null"
          ],
          "default": ""
        }
      }
    },
    "returns": {
      "description": "Returns a string containing a string representation of all the array elements in the same order, with the separator between each element.",
      "schema": {
        "type": "string"
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            "Hello",
            "World"
          ],
          "separator": " "
        },
        "returns": "Hello World"
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            0
          ]
        },
        "returns": "1234567890"
      },
      {
        "arguments": {
          "data": [
            null,
            true,
            false,
            1,
            -1.5,
            ""
          ],
          "separator": "\n"
        },
        "returns": "null\ntrue\nfalse\n1\n-1.5\n"
      },
      {
        "arguments": {
          "data": [
            2,
            0
          ],
          "separator": 1
        },
        "returns": "210"
      },
      {
        "arguments": {
          "data": []
        },
        "returns": ""
      }
    ]
  },
  {
    "id": "trim",
    "summary": "Remove slices with no-data values",
    "description": "Removes slices solely containing no-data values. If the dimension is irregular categorical then slices in the middle can be removed.",
    "categories": [
      "cubes"
    ],
    "parameters": {
      "data": {
        "description": "A raster data cube to trim.",
        "schema": {
          "type": "object",
          "format": "raster-cube"
        },
        "required": true
      }
    },
    "returns": {
      "description": "A trimmed raster data cube.",
      "schema": {
        "type": "object",
        "format": "raster-cube"
      }
    }
  },
  {
    "id": "variance",
    "summary": "Variance",
    "description": "Computes the sample variance of an array of numbers by calculating the square of the standard deviation (see ``sd()``). It is defined to be the expectation of the squared deviation of a random variable from its expected value. Basically, it measures how far the numbers in the array are spread out from their average value.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameter_order": [
      "data",
      "ignore_nodata"
    ],
    "parameters": {
      "data": {
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "The computed sample variance.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            -1,
            1,
            3
          ]
        },
        "returns": 4
      },
      {
        "arguments": {
          "data": [
            2,
            3,
            3,
            null,
            4,
            4,
            5
          ]
        },
        "returns": 1.1
      },
      {
        "arguments": {
          "data": [
            -1,
            1,
            null,
            3
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Variance.html",
        "title": "Variance explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "xor",
    "summary": "Is exactly one value true?",
    "description": "Checks if **exactly one** of the values is true. Evaluates each expression from the first to the last element and stops once the outcome is unambiguous.\n\nIf only one value is given the process evaluates to the given value. If no value is given (i.e. the array is empty) the process returns `null`.\n\nBy default all no-data values are ignored so that the process returns `true` if exactly one of the other values is true and otherwise returns `false`.\nSetting the `ignore_nodata` flag to `false` considers no-data values so that `null` is a valid logical object. If a component is `null`, the result will be `null` if the outcome is ambiguous. See the following truth table:\n\n```\n      || null | false | true\n----- || ---- | ----- | -----\nnull  || null | null  | null\nfalse || null | false | true\ntrue  || null | true  | false\n```",
    "categories": [
      "logic",
      "reducer"
    ],
    "parameter_order": [
      "expressions",
      "ignore_nodata"
    ],
    "parameters": {
      "expressions": {
        "description": "A set of boolean values.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "boolean",
              "null"
            ]
          }
        },
        "required": true
      },
      "ignore_nodata": {
        "description": "Indicates whether no-data values are ignored or not and ignores them by default.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "returns": {
      "description": "Boolean result of the logical expressions.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "expressions": [
            false,
            null
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true,
            null
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            false,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "expressions": [
            true,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "expressions": [
            true,
            false,
            true,
            false
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true,
            false
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": [
            false,
            false
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "expressions": [
            true
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "expressions": []
        },
        "returns": null
      }
    ]
  }
]